{
  "hash": "971e6344b7cac5cf6b9654b6091d24bc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Methods of scaling applied to easier examples\"\nformat: \n  html:\n    css: styles.css\n    code-fold: true\n    embed-resources: true\n\nexecute:\n  eval: false\n  echo: true\n\nhighlight-style: solarized\n---\n\n<h4>A one-factor model.</h4>\n\n<details>\n  <summary>Model for Reference-Group Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/OneFactor1.svg\">  \n</details> \n\n<details>\n  <summary>Model for Marker-Variable Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/OneFactor2.svg\">  \n</details> \n\n<details>\n  <summary>Model for Effects-Scaling Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/OneFactor3.svg\">  \n</details> \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"OneFactor.r\"}\n#### Methods of Scaling and Identification\n\n## Some easier examples.\n## Demonstrates three methods of scaling in a one-factor model:\n## 1. Reference-Group Method - Constrain latent variable's variance and mean;\n## 2. Marker-Variable Method - Constrain one loading and that indicator's intercept;\n## 3. Effects-Scaling Method - Constrain sums of loadings and intercepts.\n\n## Compare results with lavaan's results\n\n## One Factor:\n#  \"Positive Affect\" factor for 7th grade\n\n# Data in Appendix A of:\n# Little, T., Slegers, D., & Card, N. (2006). A non-arbitrary method of\n# identifying and scaling latent variables in SEM and MACS models.\n# Structural Equation Modeling, 13(1), 59-72.\n\n## Load package\nlibrary(OpenMx)\n\n## Get data\n# Vectors of correlations (row-by-row), standard deviations, and means, and sample size.\nvcor <- c(\n   1.00000,\n   0.75854,  1.00000,\n   0.76214,  0.78705,  1.00000)\n\nvmean <- c(3.13552, 2.99061, 3.06945)\nvsd <- c(0.66770, 0.68506, 0.70672)\nn <- 380\n\n# Variable names\nnames <- c(\"pos1\", \"pos2\", \"pos3\")\n\n# Get full correlation matrix\nmcor <- matrix( , 3, 3)                          # Empty matrix\nmcor[upper.tri(mcor, diag = TRUE)] <- vcor       # Fill the upper triangle\nmcor <- pmax(mcor, t(mcor), na.rm = TRUE)        # Fill the lower triangle\n\n# Get co/variance matrix\nmcov <- outer(vsd, vsd) * mcor\n\n# Name the rows and columns\ndimnames(mcov) <- list(names, names); mcov\n\nnames(vmean) <- names   # OpenMx requires the means be named\n\n# Get data into OpenMx format\ndata <- mxData(observed = mcov, type = \"cov\", means = vmean, numObs = n)\n\n\n### Method 1: Reference-Group Method\n## Constrain latent variance to 1\n## Constrain latent mean to 0\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings <- mxPath(from = \"POS\", to = names, arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\n# Factor variance - Constrain variance to 1\nvarFac <- mxPath(from = \"POS\", arrows = 2,\n   free = FALSE, values = 1,\n   labels = \"phi\")\n\n# Factor mean - Constrain mean to 0\nmeans <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = FALSE, values = 0,\n   labels = \"kappa\")\n\n# Residual variances\nvarRes <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta1\", \"theta2\", \"theta3\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\"))\n\n## Setup the model\nmodel1 <- mxModel(\"One Factor Model\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data, loadings, varFac, means, varRes, intercepts)\n\n## Run the model and get summary\nfit1 <- mxRun(model1)\nsummary(fit1)\n\n# These models are just-identified.\n# Number of variables is 3;\n# Therefore, number of pieces of information in co/variance matrix: (3 X 4) / 2 = 6\n# plus 3 means = 9 pieces of information.\n# Number of parameters:\n#   3 loadings\n#   3 redisual variances\n#   3 intercepts\n#   Total of 9 parameters\n\n# Therefore, degrees of freedom is zero,\n# chi square is 0,\n# and other fit indices are either 1 or 0.\n# There is a small discrepancy - chi sq is not quite 0.\n# Note: the log likelihoods for the model and the saturated model differ.\n# OpenMx needs to estimate reference (saturated and independence) models.\n\nsummary(fit1, refModels = mxRefModels(fit1, run = TRUE))\ncoef(fit1)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm1 <- \"\n  # Loadings\n  POS =~ NA*lambda1*pos1 + lambda2*pos2 + lambda3*pos3\n\n  # Latent variance - Constrained to 1\n  POS ~~ 1*phi*POS\n\n  # Latent mean - Constrained to 0\n  POS ~ 0*kappa*1\n\n  # Residual variances\n  pos1 ~~ theta1*pos1\n  pos2 ~~ theta2*pos2\n  pos3 ~~ theta3*pos3\n\n  # Intercepts \n  pos1 ~ tau1*1\n  pos2 ~ tau2*1\n  pos3 ~ tau3*1\n\"\n\nm1_fit <- sem(m1, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nOpenMx <- coef(fit1)\nlavaan <- coef(m1_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n\n\n### Method 2: Marker-Variable Method\n## Constrain third loading to 1\n## Constrain third intercept to 0\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings - Constrain 3rd loading to 1\nloadings <- mxPath(from = \"POS\", to = names, arrows = 1,\n   free = c(TRUE, TRUE, FALSE), values = c(0.5, 0.5, 1),\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\n# Factor variance\nvarFac <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1,\n   labels = \"phi\")\n\n# Factor mean\nmeans <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 1,\n   labels = \"kappa\")\n\n# Residual variances\nvarRes <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta1\", \"theta2\", \"theta3\"))\n\n# Intercepts - Constrain 3rd intercept to 0\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = c(TRUE, TRUE, FALSE), values = c(1, 1, 0),\n   labels = c(\"tau1\", \"tau2\", \"tau3\"))\n\n## Setup the model\nmodel2 <- mxModel(\"One Factor Model\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data, loadings, varFac, means, varRes, intercepts)\n\n## Run the model and get summary\nfit2 <- mxRun(model2)\nsummary(fit2, refModels = mxRefModels(fit2, run = TRUE))\ncoef(fit2)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm2 <- \"\n  # Loadings - Constrain 3rd loading to 1\n  POS =~ NA*lambda1*pos1 + lambda2*pos2 + 1*lambda3*pos3\n\n  # Latent variance\n  POS ~~ phi*POS\n\n  # Latent mean\n  POS ~ kappa*1\n\n  # Residual variances\n  pos1 ~~ theta1*pos1\n  pos2 ~~ theta2*pos2\n  pos3 ~~ theta3*pos3\n\n  # Intercepts - Constrain 3rd intercept to 0\n  pos1 ~ tau1*1\n  pos2 ~ tau2*1\n  pos3 ~ 0*tau3*1\n\"\n\nm2_fit <- sem(m2, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nOpenMx <- coef(fit2)\nlavaan <- coef(m2_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]      \ncbind(OpenMx, lavaan)\n########################\n\n\n### Method 3: Effects-Scaling Method\n## Constrain sum of loadings to equal number of loadings\n## Constrain sum of intercepts to equal 0\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings <- mxPath(from = \"POS\", to = names, arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\n# Factor variance\nvarFac <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1,\n   labels = \"phi\")\n\n# Factor mean\nmeans <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 1,\n   labels = \"kappa\")\n\n# Residual variances\nvarRes <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta1\", \"theta2\", \"theta3\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\"))\n\n# Constraints\nconLoad <- mxConstraint(lambda1 + lambda2 + lambda3 == 3)\nconInter <- mxConstraint(tau1 + tau2 + tau3 == 0)\n\n## Setup the model\nmodel3 <- mxModel(\"One Factor Model\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data, loadings, means, varFac, varRes, intercepts,\n   conLoad, conInter)\n\n## Run the model and get summary\nfit3 <- mxRun(model3)\nsummary(fit3, refModels = mxRefModels(fit3, run = TRUE))\ncoef(fit3)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm3 <- \"\n  # Loadings\n  POS =~ NA*lambda1*pos1 + lambda2*pos2 + lambda3*pos3\n\n  # Latent variance\n  POS ~~ phi*POS\n\n  # Latent mean\n  POS ~ kappa*1\n\n  # Residual variances\n  pos1 ~~ theta1*pos1\n  pos2 ~~ theta2*pos2\n  pos3 ~~ theta3*pos3\n\n  # Intercepts \n  pos1 ~ tau1*1\n  pos2 ~ tau2*1\n  pos3 ~ tau3*1\n\n  # Constraints\n  lambda1 + lambda2 + lambda3 == 3\n  tau1 + tau2 + tau3 == 0\n\"\n\nm3_fit <- sem(m3, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nOpenMx <- coef(fit3)\nlavaan <- coef(m3_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n```\n:::\n\n\n\n<h4>A two-factor model</h4>\n\n<details>\n  <summary>Model for Reference-Group Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/TwoFactor1.svg\">  \n</details> \n\n<details>\n  <summary>Model for Marker-Variable Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/TwoFactor2.svg\">  \n</details> \n\n<details>\n  <summary>Model for Effects-Scaling Method</summary>\n  <img src=\"../Drawing_SEMs//Little_2006/TwoFactor3.svg\">  \n</details> \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"TwoFactor.r\"}\n#### Methods of Scaling and Identification\n\n## Some easier examples.\n## Demonstrates three methods of scaling in two-factor model:\n## 1. Reference-Group Method - Constrain latent variables' variances and means;\n## 2. Marker-Variable Method - Constrain one loading and that indicator's\n##    intercept in both factors;\n## 3. Effects-Scaling Method - Constrain sums of loadings and intercepts\n##    for both factors.\n\n## Compare results with lavaan's results\n\n## Two Factors\n#  \"Positive Affect\" and \"Negative Affect\" factors for 7th grade\n\n# Data in Appendix A of:\n# Little, T., Slegers, D., & Card, N. (2006). A non-arbitrary method of\n# identifying and scaling latent variables in SEM and MACS models.\n# Structural Equation Modeling, 13(1), 59-72.\n\n## Load package\nlibrary(OpenMx)\n\n## Get data\n# Vectors of correlations (row-by-row), standard deviations, and means, and sample size.\nvcor <- c(\n   1.00000,\n   0.75854,  1.00000,\n   0.76214,  0.78705,  1.00000,\n   0.02766,  0.00973, -0.05762,  1.00000,\n  -0.06112, -0.06105, -0.14060,  0.78501,  1.00000,\n  -0.02222, -0.05180, -0.10250,  0.81616,  0.81076,  1.00000)\n\nvmean <- c(3.13552, 2.99061, 3.06945, 1.70069, 1.52705, 1.54483)\nvsd <- c(0.66770, 0.68506, 0.70672, 0.71418, 0.66320, 0.65276)\nn <- 380\n\n# Variable names\nnames <- c(\"pos1\", \"pos2\", \"pos3\", \"neg1\", \"neg2\", \"neg3\")\n\n# Get full correlation matrix\nmcor <- matrix( , 6, 6)                          # Empty matrix\nmcor[upper.tri(mcor, diag = TRUE)] <- vcor       # Fill the upper triangle\nmcor <- pmax(mcor, t(mcor), na.rm = TRUE)        # Fill the lower triangle\n\n# Get co/variance matrix\nmcov <- outer(vsd, vsd) * mcor\n\n# Name the rows and columns\ndimnames(mcov) <- list(names, names)\nmcov\n\nnames(vmean) <- names   # OpenMx requires the means be named\n\n# Get data into OpenMx format\ndata <- mxData(observed = mcov, type = \"cov\", means = vmean, numObs = n)\n\n\n### Method 1: Reference-Group Method\n## Constrain latent variances to 1\n## Constrain latent means to 0\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings1 <- mxPath(from = \"POS\", to = c(\"pos1\", \"pos2\", \"pos3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\nloadings2 <- mxPath(from = \"NEG\", to = c(\"neg1\", \"neg2\", \"neg3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda4\", \"lambda5\", \"lambda6\"))\n\n# Factor variances and covariance - constrain variances to 1\nvarFac <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = c(FALSE, TRUE, FALSE), values = 1,\n   labels = c(\"phi11\", \"phi12\", \"phi22\"))\n\n# Factor means - constrain means to 0\nmeans <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = FALSE, values = 0,\n   labels = c(\"kappa1\", \"kappa2\"))\n\n# Residual variances\nvarRes <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"theta1\", \"theta2\", \"theta3\", \"theta4\", \"theta5\", \"theta6\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\", \"tau4\", \"tau5\", \"tau6\"))\n\n## Setup the model\nmodel1 <- mxModel(\"Two Factor Model\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data, loadings1, loadings2, varFac, means, varRes, intercepts)\n\n## Run the model and get summary\nfit1 <- mxRun(model1)\nsummary(fit1)\n\n# Number of variables is 6;\n# Number of pieces of information in covariance matrix: (6 X 7) / 2 = 21\n# plus 6 means = 27 pieces of information\n# Number of parameters:\n#   6 loadings (3 per factor)\n#   1 covariance between factors\n#   6 residual variances (3 per factor)\n#   6 intercepts (3 per factor)\n#   Total of 19 parameters\n \n# Therefore, degrees of freedom = 8,\n# and chi sq and fit indices are calculated.\n# But make sure OpenMx estimates reference models (saturated and independence)\n# upon which to base calculations for chi sq and fit indices.\n\nsummary(fit1, refModels = mxRefModels(fit1, run = TRUE))\ncoef(fit1)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm1 <- \"\n  # Loadings\n  POS =~ NA*lambda1*pos1 + lambda2*pos2 + lambda3*pos3\n  NEG =~ NA*lambda4*neg1 + lambda5*neg2 + lambda6*neg3\n\n  # Latent variances and covariance - constrain variances to 1\n  POS ~~ 1*phi11*POS\n  NEG ~~ 1*phi22*NEG\n  POS ~~ phi12*NEG\n\n  # Latent means - constrain means to 0\n  POS ~ 0*kappa1*1\n  NEG ~ 0*kappa2*1\n\n  # Residual variances\n  pos1 ~~ theta1*pos1\n  pos2 ~~ theta2*pos2\n  pos3 ~~ theta3*pos3\n  neg1 ~~ theta4*neg1\n  neg2 ~~ theta5*neg2\n  neg3 ~~ theta6*neg3\n\n  # Intercepts \n  pos1 ~ tau1*1\n  pos2 ~ tau2*1\n  pos3 ~ tau3*1\n  neg1 ~ tau4*1\n  neg2 ~ tau5*1\n  neg3 ~ tau6*1\n\"\n\nm1_fit <- sem(m1, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nsummary(m1_fit)\nOpenMx <- coef(fit1)\nlavaan <- coef(m1_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n\n\n\n### Method 2: Marker-Variable Method\n## Constrain 3rd loading for POS and 1st loading for NEG to 1\n## Constrain 3rd intercept for POS and 1st intercept for NEG to 0\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings - Constrain 3rd loading for POS & 1st loading for NEG to 1\nloadings1 <- mxPath(from = \"POS\", to = c(\"pos1\", \"pos2\", \"pos3\"), arrows = 1,\n   free = c(TRUE, TRUE, FALSE), values = c(0.5, 0.5, 1),\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\nloadings2 <- mxPath(from = \"NEG\", to = c(\"neg1\", \"neg2\", \"neg3\"), arrows = 1,\n   free = c(FALSE, TRUE, TRUE), values = c(1, 0.5, 0.5),\n   labels = c(\"lambda4\", \"lambda5\", \"lambda6\"))\n\n# Factor variances and covariance\nvarFac <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = c(1, 0.5, 1),\n   labels = c(\"phi11\", \"phi12\", \"phi22\"))\n\n# Factor means\nmeans <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa1\", \"kappa2\"))\n\n# Residual variances\nvarRes <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta1\", \"theta2\", \"theta3\", \"theta4\", \"theta5\", \"theta6\"))\n\n# Intercepts - constrain 3rd intercept for POS & 1st intercept for NEG to 0\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE),\n   values = c(1, 1, 0, 0, 1, 1),\n   labels = c(\"tau1\", \"tau2\", \"tau3\", \"tau4\", \"tau5\", \"tau6\"))\n\n## Setup the model\nmodel2 <- mxModel(\"Two Factor Model\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data, loadings1, loadings2, varFac, means, varRes, intercepts)\n\n## Run the model and get summary\nfit2 <- mxRun(model2)\nsummary(fit2, refModels = mxRefModels(fit2, run = TRUE))\ncoef(fit2)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm2 <- \"\n  # Loadings - Constrain 3rd loading for POS & 1st loading for NEG to 1\n  POS =~ NA*lambda1*pos1 + lambda2*pos2 + 1*lambda3*pos3\n  NEG =~  1*lambda4*neg1 + lambda5*neg2 + lambda6*neg3\n\n  # Latent variances and covariance\n  POS ~~ phi11*POS\n  NEG ~~ phi22*NEG\n  POS ~~ phi12*NEG\n\n  # Latent means \n  POS ~ kappa1*1\n  NEG ~ kappa2*1\n\n  # Residual variances\n  pos1 ~~ theta1*pos1\n  pos2 ~~ theta2*pos2\n  pos3 ~~ theta3*pos3\n  neg1 ~~ theta4*neg1\n  neg2 ~~ theta5*neg2\n  neg3 ~~ theta6*neg3  \n\n  # Intercepts - Constrain 3rd intercept for POS & 1st intercept for NEG to 0\n  pos1 ~ tau1*1\n  pos2 ~ tau2*1\n  pos3 ~ 0*tau3*1\n  neg1 ~ 0*tau4*1\n  neg2 ~ tau5*1\n  neg3 ~ tau6*1\n\"\n\nm2_fit <- sem(m2, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nOpenMx <- coef(fit2)\nlavaan <- coef(m2_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n\n\n### Method 3: Effects-Scaling Method\n## Constrain sum of loadings to equal number of loadings\n## Constrain sum of intercepts to equal 0\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings1 <- mxPath(from = \"POS\", to = c(\"pos1\", \"pos2\", \"pos3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\nloadings2 <- mxPath(from = \"NEG\", to = c(\"neg1\", \"neg2\", \"neg3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda4\", \"lambda5\", \"lambda6\"))\n\n# Factor variances and covariance\nvarFac <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = 1, labels = c(\"phi11\", \"phi12\", \"phi22\"))\n\n# Factor means\nmeans <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa1\", \"kappa2\"))\n\n# Residual variances\nvarRes <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta1\", \"theta2\", \"theta3\", \"theta4\", \"theta5\", \"theta6\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\", \"tau4\", \"tau5\", \"tau6\"))\n\n# Constraints\nconLoadPOS <- mxConstraint(lambda1 + lambda2 + lambda3 == 3)\nconLoadNEG <- mxConstraint(lambda4 + lambda5 + lambda6 == 3)\nconInterPOS <- mxConstraint(tau1 + tau2 + tau3 == 0)\nconInterNEG <- mxConstraint(tau4 + tau5 + tau6 == 0)\n\n## Setup the model\nmodel3 <- mxModel(\"Two Factor Model\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data, loadings1, loadings2, varFac, means, varRes, intercepts,\n   conLoadPOS, conLoadNEG, conInterPOS, conInterNEG)\n\n## Run the model and get summary\nfit3 <- mxRun(model3)\nsummary(fit3, refModels = mxRefModels(fit3, run = TRUE))\ncoef(fit3)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm3 <- \"\n  # Loadings\n  POS =~ NA*lambda1*pos1 + lambda2*pos2 + lambda3*pos3\n  NEG =~ NA*lambda4*neg1 + lambda5*neg2 + lambda6*neg3\n\n  # Latent variances and covariance\n  POS ~~ phi11*POS\n  NEG ~~ phi22*NEG\n  POS ~~ phi12*NEG\n\n  # Latent means\n  POS ~ kappa1*1\n  NEG ~ kappa2*1\n\n  # Residual variances\n  pos1 ~~ theta1*pos1\n  pos2 ~~ theta2*pos2\n  pos3 ~~ theta3*pos3\n  neg1 ~~ theta4*neg1\n  neg2 ~~ theta5*neg2\n  neg3 ~~ theta6*neg3\n\n  # Intercepts \n  pos1 ~ tau1*1\n  pos2 ~ tau2*1\n  pos3 ~ tau3*1\n  neg1 ~ tau4*1\n  neg2 ~ tau5*1\n  neg3 ~ tau6*1\n\n  # Constraints\n  lambda1 + lambda2 + lambda3 == 3\n  lambda4 + lambda5 + lambda6 == 3\n\n  tau1 + tau2 + tau3 == 0\n  tau4 + tau5 + tau6 == 0\n\"\n\nm3_fit <- sem(m3, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nsummary(m3_fit)\nOpenMx <- coef(fit3)\nlavaan <- coef(m3_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n```\n:::\n\n\n\n<h4>A one-factor two-group model</h4>\n\n<details>\n  <summary>Model for Reference-Group Method</summary>\n    <img src=\"../Drawing_SEMs/Little_2006/OneFactorTwoGroups1.svg\">  \n</details> \n\n<details>\n  <summary>Model for Marker-Variable Method</summary>\n    <img src=\"../Drawing_SEMs/Little_2006/OneFactorTwoGroups2.svg\">  \n</details> \n\n<details>\n  <summary>Model for Effects-Scaling Method</summary>\n    <img src=\"../Drawing_SEMs/Little_2006/OneFactorTwoGroups3.svg\">  \n</details> \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"OneFactorTwoGroup.r\"}\n#### Methods of Scaling and Identification\n\n## Some easier examples.\n## Demonstrates three methods of scaling in one-factor, two-group model:\n## 1. Reference-Group Method - Constrain latent variable's variance and mean;\n## 2. Marker-Variable Method - Constrain one loading and that indicator's intercept;\n## 3. Effects-Scaling Method - Constrain sums of loadings and intercepts.\n\n## Following Little et al's lead, assume strong metric invariance:\n## corresponding loadings and intercepts constrained to equality across groups\n\n## Compare results from OpenMx with lavaan's results\n\n## One Factor, Two Groups\n#  \"Positive Affect\" factor for 7th and 8th grades\n\n# Data in Appendix A of:\n# Little, T., Slegers, D., & Card, N. (2006). A non-arbitrary method of\n# identifying and scaling latent variables in SEM and MACS models.\n# Structural Equation Modeling, 13(1), 59-72.\n\n## Load package\nlibrary(OpenMx)\n\n## Get data\n# Vectors of correlations (row-by-row), standard deviations, and means, and sample size.\n# 7th grade\nvcor7 <- c(\n   1.00000,\n   0.75854,  1.00000,\n   0.76214,  0.78705,  1.00000)\n\nvmean7 <- c(3.13552, 2.99061, 3.06945)\nvsd7 <- c(0.66770, 0.68506, 0.70672)\nn7 <- 380\n\n# 8th grade\nvcor8 <- c(\n   1.00000,\n   0.81366,  1.00000,\n   0.84980,  0.83523,  1.00000)\n\nvmean8 <- c(3.07338, 2.84716, 2.97882)\nvsd8 <- c(0.70299, 0.71780, 0.76208)\nn8 <- 379\n\n# Variable names\nnames <- c(\"pos1\", \"pos2\", \"pos3\")\n\n# Get full correlation matrix for each Grade\nmcor7 <- matrix( , 3, 3)                           # Empty matrix\nmcor7[upper.tri(mcor7, diag = TRUE)] <- vcor7      # Fill the upper triangle\nmcor7 <- pmax(mcor7, t(mcor7), na.rm = TRUE)       # Fill the lower triangle\n\nmcor8 <- matrix( , 3, 3)                           # Empty matrix\nmcor8[upper.tri(mcor8, diag = TRUE)] <- vcor8      # Fill the upper triangle\nmcor8 <- pmax(mcor8, t(mcor8), na.rm = TRUE)       # Fill the lower triangle\n\n# Get co/variance matrices\nmcov7 <- outer(vsd7, vsd7) * mcor7\nmcov8 <- outer(vsd8, vsd8) * mcor8\n\n# Name the rows and columns\ndimnames(mcov7) <- list(names, names)\ndimnames(mcov8) <- list(names, names)\nmcov7; mcov8\n\nnames(vmean7) <- names   # OpenMx requires the means be named\nnames(vmean8) <- names\n\n# Put data into lists - used in lavaan analysis\nmcov <- list(\"Grade 7\" = mcov7, \"Grade 8\" = mcov8)\nvmean <- list(vmean7, vmean8)\nn <- list(n7, n8)\n\n# Get data into OpenMx format\ndata7 <- mxData(observed = mcov7, type = \"cov\", means = vmean7, numObs = n7)\ndata8 <- mxData(observed = mcov8, type = \"cov\", means = vmean8, numObs = n8)\n\n\n### Method 1: Reference-Group Method\n## Constrain latent variance to 1\n## Constrain latent mean to 0\n## These constraints apply to Grade 7 only.\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings <- mxPath(from = \"POS\", to = names, arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\n# Factor variances - Constrain Grade 7 variance to 1\nvarFac7 <- mxPath(from = \"POS\", arrows = 2,\n   free = FALSE, values = 1, labels = \"phi7\")\n\nvarFac8 <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"phi8\")\n\n# Factor means - Constrain Grade 7 mean to 0\nmeans7 <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = FALSE, values = 0, labels = \"kappa7\")\n\nmeans8 <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"kappa8\") \n\n# Residual variances\nvarRes7 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta71\", \"theta72\", \"theta73\"))\n\nvarRes8 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"theta81\", \"theta82\", \"theta83\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\"))\n\n## Setup models for each Grade\nmodGr7 <- mxModel(\"Grade7\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data7, loadings, varFac7, means7, varRes7, intercepts)\n\nmodGr8 <- mxModel(\"Grade8\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data8, loadings, varFac8, means8, varRes8, intercepts)\n\n## Combine the two models\nfun <- mxFitFunctionMultigroup(c(\"Grade7.fitfunction\", \"Grade8.fitfunction\"))\nmodel1 <- mxModel(\"One Factor Two Group Model\", modGr7, modGr8, fun)\n\n## Run the model and get summary\nfit1 <- mxRun(model1)\nsummary(fit1)\n\n# Number of variables: 3\n# Number of pices of information in co/variance matrix: (3 X 4) / 2 = 6\n# plus 3 means = 9 pieces of information for each group;\n# that is, 18 for the model\n\n# Number of parameters:\n#   3 loadings (constrained to equality across groups)\n#   1 latent mean\n#   1 latent variance\n#   6 residual variances (3 per group)\n#   3 intercepts (constrained to equality across groups)\n#   Total of 14 parameters\n\n# Therefore, degrees of freedom = 4,\n# and chi sq and fit indices are calculated.\n# But make sure OpenMx estimates the reference models\n# upon which to base calculations for chi sq and fit indices.\n\nsummary(fit1, refModels = mxRefModels(fit1, run = TRUE))\ncoef(fit1)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm1 <- \"\n  # Loadings\n  POS =~ c(NA,NA)*c(lambda1, lambda1)*pos1 + c(lambda2, lambda2)*pos2 + c(lambda3, lambda3)*pos3\n\n  # Latent variances - Constrain Grade 7 variance to 1\n  POS ~~ c(1, NA)*c(phi7, phi8)*POS\n\n  # Latent means - Constrain Grade 7 mean to 0\n  POS ~ c(0, NA)*c(kappa7, kappa8)*1\n\n  # Residual variances\n  pos1 ~~ c(theta71, theta81)*pos1\n  pos2 ~~ c(theta72, theta82)*pos2\n  pos3 ~~ c(theta73, theta83)*pos3\n\n  # Intercepts\n  pos1 ~ c(tau1, tau1)*1\n  pos2 ~ c(tau2, tau2)*1\n  pos3 ~ c(tau3, tau3)*1\n\"\n\nm1_fit <- sem(m1, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nsummary(m1_fit)\nOpenMx <- coef(fit1)\nlavaan <- coef(m1_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n\n\n### Method: Marker-Variable Method\n## Constrain third loading in POS to 1\n## Constrain third intercept to 0\n## With strong measurement invariance,\n## these constraints apply to both Grades.\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings - Constrain 3rd loading to 1\nloadings <- mxPath(from = \"POS\", to = names, arrows = 1,\n   free = c(TRUE, TRUE, FALSE), values = c(0.5, 0.5, 1),\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\n# Factor variances\nvarFac7 <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"phi7\")\n\nvarFac8 <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"phi8\")\n\n# Factor means\nmeans7 <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"kappa7\")\n\nmeans8 <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"kappa8\")\n\n# Residual variances\nvarRes7 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta71\", \"theta72\", \"theta73\"))\n\nvarRes8 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta81\", \"theta82\", \"theta83\"))\n\n# Intercepts - Constrain 3rd intercept to 0\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = c(TRUE, TRUE, FALSE), values = c(1, 1, 0),\n   labels = c(\"tau1\", \"tau2\", \"tau3\"))\n\n## Setup models for each Grade\nmodGr7 <- mxModel(\"Grade7\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data7, loadings, varFac7, means7, varRes7, intercepts)\n\nmodGr8 <- mxModel(\"Grade8\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data8, loadings, varFac8, means8, varRes8, intercepts)\n\n## Combine the two models using \"mxFitFunctionMultigroup()\"\nfun <- mxFitFunctionMultigroup(c(\"Grade7.fitfunction\", \"Grade8.fitfunction\"))\nmodel2 <- mxModel(\"One Factor Two Group Model\", modGr7, modGr8, fun)\n\n## Run the model and get summary\nfit2 <- mxRun(model2)\nsummary(fit2, refModels = mxRefModels(fit2, run = TRUE))\ncoef(fit2)\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm2 <- \"\n  # Loadings - Constrain 3rd loading to 1 in both Grades\n  POS =~ c(NA,NA)*c(lambda1, lambda1)*pos1 + c(lambda2, lambda2)*pos2 + c(1,1)*c(lambda3, lambda3)*pos3\n\n  # Latent variances\n  POS ~~ c(phi7, phi8)*POS\n\n  # Latent means\n  POS ~ c(kappa7, kappa8)*1\n\n  # Residual variances\n  pos1 ~~ c(theta71, theta81)*pos1\n  pos2 ~~ c(theta72, theta82)*pos2\n  pos3 ~~ c(theta73, theta83)*pos3\n\n  # Intercepts - Constrain 3rd intercept to 0 in both Grades\n  pos1 ~ c(tau1, tau1)*1\n  pos2 ~ c(tau2, tau2)*1\n  pos3 ~ c(0,0)*c(tau3, tau3)*1\n\"\n\nm2_fit <- sem(m2, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nsummary(m2_fit)\nOpenMx <- coef(fit2)\nlavaan <- coef(m2_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n\n\n### Method 3\n## Constrain sum of loadings to equal number of loadings\n## Constrain sum of intercepts to equal 0\n## With strong measurement invariance,\n## these constraints apply to both Grades.\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings <- mxPath(from = \"POS\", to = names, arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\n# Factor variances\nvarFac7 <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"phi7\")\n\nvarFac8 <- mxPath(from = \"POS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"phi8\")\n\n# Factor means\nmeans7 <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 0, labels = \"kappa7\")\n\nmeans8 <- mxPath(from = \"one\", to = \"POS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"kappa8\")\n\n# Residual variances\nvarRes7 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta71\", \"theta72\", \"theta73\"))\n\nvarRes8 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta81\", \"theta82\", \"theta83\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\"))\n\n## Setup models for each Grade\nmodGr7 <- mxModel(\"Grade7\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data7, loadings, varFac7, means7, varRes7, intercepts)\n\nmodGr8 <- mxModel(\"Grade8\", type = \"RAM\",\n   manifestVars = names, latentVars = \"POS\",\n   data8, loadings, varFac8, means8, varRes8, intercepts)\n\n## Constraints\nconLoad <- mxConstraint(lambda1 + lambda2 + lambda3 == 3)\nconInter <- mxConstraint(tau1 + tau2 + tau3 == 0)\n\n## Combine the two models\nfun <- mxFitFunctionMultigroup(c(\"Grade7.fitfunction\", \"Grade8.fitfunction\"))\nmodel3 <- mxModel(\"One Factor Two Group Model\", modGr7, modGr8,\n   conLoad, conInter, fun)\n\n# Note: Constraints are added to final model, not to each of the Grade7 and Grade 8 models;\n# otherwise, OpenMx will count them as 4 constraints, accounting for 4 degrees of freedom,\n# instead of 2.\n\n## Run the model and get summary\nfit3 <- mxRun(model3)\nsummary(fit3, refModels = mxRefModels(fit3, run = TRUE))\n\n# Counting degrees of freedom.\n# Number of variables: 3\n# Number of pieces of information in the covariance matrix: 6\n# plus 3 means = 9 per group;\n# that is, 18 for the model\n\n# Number of parameters:\n# 3 loadings (constrained to equality across the groups)\n# 3 intercepts (constrained to equality across the groups)\n# 6 residual variances (3 per group)\n# 2 latent means (1 per group)\n# 2 latent variances (1 per group)\n# Total of 16\n# but take away 2 for the 2 constraints = 14,\n# resulting in 18 - 14 = 4 degrees of freedom.\n#\n# If the constraints were added to each Grade's model,\n# OpenMx would have counted them as 4 constraints (even thought they are identical),\n# resulting in 6 degrees of freedom for the model.\n\n########################\n## Check with lavaan\nlibrary(lavaan)\n\nm3 <- \"\n  # Loadings\n  POS =~ c(NA,NA)*c(lambda1, lambda1)*pos1 + c(lambda2, lambda2)*pos2 + c(lambda3, lambda3)*pos3\n\n  # Latent variances\n  POS ~~ c(phi7, phi8)*POS\n\n  # Latent means\n  POS ~ c(kappa7, kappa8)*1\n\n  # Residual variances\n  pos1 ~~ c(theta71, theta81)*pos1\n  pos2 ~~ c(theta72, theta82)*pos2\n  pos3 ~~ c(theta73, theta83)*pos3\n\n  # Intercepts\n  pos1 ~ c(tau1, tau1)*1\n  pos2 ~ c(tau2, tau2)*1\n  pos3 ~ c(tau3, tau3)*1\n\n  # Constraints\n  lambda1 + lambda2 + lambda3 == 3\n  tau1 + tau2 + tau3 == 0\n\"\n\nm3_fit <- sem(m3, sample.cov = mcov, sample.nobs = n, sample.mean = vmean)\nsummary(m3_fit)\nOpenMx <- coef(fit3)\nlavaan <- coef(m3_fit)\n\n# Get coefs in same order\nlavaan <- lavaan[match(names(OpenMx), names(lavaan))]\ncbind(OpenMx, lavaan)\n########################\n```\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}