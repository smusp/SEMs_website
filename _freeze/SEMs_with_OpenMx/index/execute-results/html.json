{
  "hash": "aed27415ae07f254326e40634043a073",
  "result": {
    "engine": "knitr",
    "markdown": "---\nhighlight-style: solarized\nembed-resources: true\ncss: styles.css\ncode-fold: true\n\nexecute:\n  eval: false\n---\n\n:::: {layout=\"[60, 40]\" layout-valign=\"center\"}\n\n::: {#leftcolumn}\n<h2 style = \"margin: 0px;\"> Reproducing published Structural Equation Models with OpenMx </h2>\n:::\n\n::: {#rightcolumn}\n  <img style = \"margin: 0px; padding: 0px;\" src=\"logo/logo.svg\">\n:::\n\n::::\n\nThis post presents **R** scripts to reproduce published Structural Equation Modeling analyses using **OpenMx**. \n\nClick on the **R** file to see the R script.\nClick on the model to see a diagram of the model.\n\n#### The publications\n\n- Jose, P. (2013). *Doing statistical mediation and moderation*. New York, NY: Guilford Press. <br/> A basic three-variable mediation analysis (See Chapter 3).\n\n<details class=\"image-fold\">\n  <summary>Mediation model</summary>\n  <img src=\"../Drawing_SEMs/Jose_2013/Jose_2013.svg\">  \n</details> \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Jose_2013.r\"}\n## Jose, P. (2013). Doing statistical mediation and moderation. \n## New York, NY: Guilford Press.\n\n## Chapter 3 describes a basic three-variable mediation analysis.\n\n## Load packages\nlibrary(OpenMx)\nlibrary(haven)   # To read SPSS data files\n\n# OpenMx is very verbose;\n# it requires everything to be coded;\n# means and intercepts must be included.\n\n## Get the data from Guilford Press web site\nurl <- \"http://www.guilford.com/add/jose/mediation_example.sav\"\ndf <- data.frame(haven::read_spss(url))\n\nstr(df)\nhead(df)\nsummary(df)\n\n## The model is shown in Fig 3.3 (p. 46);\n## or see the model diagram above.\n\n#### Collect the bits and pieces needed by OpenMx\n## Get the names of the variables\nmanifest <- names(df)\n\n## Get data into OpenMx format\ndataRaw <- mxData(observed = df, type = \"raw\")\n\n## Regressions\n#  - Arrows from \"ple\" and \"grat\" to \"shs\".\n#  - Arrows are single headed - arrow head at \"shs\".\n#  - Starting values are 0.5.  When they are the same,\n#    they need to be listed once only.\n#  - Labels are \"cprime\" for arrow \"ple\" to \"shs\";\n#    and \"b\" for arrow \"grat\" to \"shs\".\nregPaths1 <- mxPath(from = c(\"ple\", \"grat\"), to = \"shs\",\n   arrows = 1, values = 0.5,\n   labels = c(\"cprime\", \"b\"))\n\n#  - Arrow from \"ple\" to \"grat\".\n#  - Arrow is single headed - arrow head at \"grat\".\n#  - Starting value is 0.5.\n#  - Label is \"a\".\nregPaths2 <- mxPath(from = \"ple\", to = \"grat\",\n   arrows = 1, values = 0.5,\n   labels = \"a\")\n\n## Variances\n## Exogenous variables (\"ple\") have variances;\n## Endogenous variables (\"grat\" and \"shs\") have residual or error variances.\n## Variance for exogenous variable is not shown in the model diagram.\n## The distinction does not matter to OpenMx, but I distinguish in the labels.\n\n#  - Arrows are from manifest variables to manifest variables\n#    (when \"arrows = 2\", the \"to\" argument can be omitted); \n#    ie, from \"ple\" to \"ple\"; from \"grat\" to \"grat\"; and from \"shs\" to \"shs\".\n#  - Arrows are two headed.\n#  - Starting values are 1.\n#  - Labels are \"vPLE\" \"eGRAT\", and \"eSHS\".\nvarPaths <- mxPath(from = manifest,\n   arrows = 2, values = 1,\n   labels = c(\"vPLE\", \"eGRAT\", \"eSHS\"))\n\n## Means and intercepts\n## Exogenous variables (\"ple\") have means;\n## Endogenous variables (\"grat\" and \"shs\") have intercepts.\n## Regress variables on a constant - in OpenMx, \"one\".\n## Means and intercepts are not shown in the model diagram.\n## The distinction does not matter to OpenMx, but I distinguish in the labels.\n\n#  - Arrows from \"one\" to the manifest variables;\n#    ie, from \"one\" to \"ple\"; from \"one\" to \"grat\"; from \"one\" to \"shs\".\n#  - Arrows are single headed.\n#  - Starting values are 1.\n#  - labels are \"mPLE\", \"iGRAT\", \"iSHS\".\nmeans <- mxPath(from = \"one\", to = manifest,\n   arrows = 1, values = 1,\n   labels = c(\"mPLE\", \"iGRAT\", \"iSHS\"))\n\n## Indirect and total effects\nindirect <- mxAlgebra(a * b, name = \"indirect\")\ntotal <- mxAlgebra(a * b + cprime, name = \"total\")\n\n## Setup the model with all the bits\nmedModel <- mxModel(model = \"Mediation\",\n   type = \"RAM\",\n   data = dataRaw,\n   manifestVars = manifest,\n   varPaths,\n   regPaths1, regPaths2,\n   means, \n   indirect, total)\n\n## Run the model and get summary\n# Compare with regression outputs in Tables 3.4 and 3.5 (p. 52)\nfit <- mxRun(medModel)\nsummary(fit)   # Note: summary() does not return indirect and total effects\ncoef(fit)      # Just the estimates\n\n## Extract indirect and total effects (and their standard errors) from \"fit\" object\n# Compare with unstandardised indirect and total effect in Fig 3.6 (p. 59).\nestimates <- mxEval(c(indirect, total), fit); estimates\nSE <- sapply(c(\"indirect\", \"total\"), function(x) mxSE(x, fit, silent = TRUE)); SE\n\n## To get the standardised effects, mxStandardizeRAMpaths(fit) will give standardised\n## effects for free parameters, but not derived effects.\n\n# Could use mxStandardizeRAMpaths(fit) to extract standardised \"a\", \"b\", and \"cprime\",\n# then calculate standardised indirect effect (a * b),\n# and standardised total effect (a * b + cprime) by hand.\n\n# Compare with standardised indirect and total effect in Fig 3.6.\n# Compare standardised regression coefficients given in Fig 3.6, or\n# in Tables 3.4 and 3.5.\nmxStandardizeRAMpaths(fit)\nestZ <- mxStandardizeRAMpaths(fit)[1:3, 8]\nnames(estZ) <- mxStandardizeRAMpaths(fit)[1:3, \"label\"]; estZ\n\nestZ[\"indirect\"] <- estZ[\"a\"] * estZ[\"b\"]\nestZ[\"total\"] <- estZ[\"indirect\"] + estZ[\"cprime\"]\nestZ\n\n## To get bootstrap CIs\nfitBoot <- mxBootstrap(fit, 2000)\n# statistics <- summary(fitBoot, boot.quantile = c(0.025, 0.975),\n#    boot.SummaryType = \"bcbci\"); statistics\n# Note: No defined effects\nci <- mxBootstrapEval(c(a, b, cprime, indirect, total), fitBoot,\n   bq = c(0.025, 0.975), method = \"bcbci\"); ci\n\n## To get likelihood-based CIs\nci <- mxCI(c(\"a\", \"b\", \"cprime\", \"indirect\", \"total\"))\n\n# Add to the model\nmedModel <- mxModel(medModel, ci)\n\n# Run the model\nfit <- mxRun(medModel, intervals = TRUE)\nsummary(fit)$CI\n```\n:::\n\n\n<br/>\n\n- Kurbanoglu, N. & Takunyaci, M. (2021). A structural equation modeling on relationship between self-efficacy, physics laboratory anxiety and attitudes. *Journal of Family, Counseling and Education*, 6(1), 47-56. <br/> A basic three-variable mediation analysis using summary data.\n\n<details class=\"image-fold\">\n  <summary>Mediation model</summary>\n  <img src=\"../Drawing_SEMs/Kurbanoglu_2021/Kurbanoglu_2021.svg\">  \n</details> \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Kurbanoglu_2021.r\"}\n## Kurbanoglu, N. & Takunyaci, M. (2021). A structural equation modeling\n## on relationship between self-efficacy, physics laboratory anxiety\n## and attitudes. Journal of Family, Counseling and Education, 6(1), 47-56.\n\n## This example shows a basic three-variable mediation\n## analysis, and how to use summary data (correlations, \n## standard deviations, and means) when the raw sample\n## are not available.\n\n## Load package\nlibrary(OpenMx)\n\n## Get the data from Table 1 (p. 50)\n# Vectors of correlations, standard deviations, and means.\n# Correlations entered row-by-row.\n# (If entered column-by-column, use 'lower.tri' in place of 'upper.tri' below.)\nvcor <- c(\n   1,\n   0.30,  1,\n  -0.42, -0.32,  1)\nvsd <- c(8.81, 7.95, 18.30)             # Standard deviations\nvmean <- c(56.57, 40.39, 68.22)         # Means\nn <- 513                                # Sample size\n\n## Get the variable names (make sure order is the same as in Table 1)\nnames <- c(\"Att\", \"SE\", \"Anx\")\n\n## Get the co/variance matrix\n# First, get full correlation matrix\nmcor = matrix( , 3, 3)                           # Empty matrix\nmcor[upper.tri(mcor, diag = TRUE)] <- vcor       # Fill the upper triangle\nmcor = pmax(mcor, t(mcor), na.rm = TRUE)         # Fill the lower triangle\n\n# Get co/variances\nmcov <- outer(vsd, vsd) * mcor\n\n# Name the rows and columns\ndimnames(mcov) <- list(names, names); mcov\nnames(vmean) = names   # OpenMx requires the means be named\n\n## The model is shown in Fig 1 (p. 51); or see the model diagram above.\n\n#### Collect the bits and pieces needed by OpenMx\n## Get data into OpenMx format\ndataCov <- mxData(observed = mcov, type = \"cov\", means = vmean, numObs = n)\n\n## Regressions\nregPaths1 <- mxPath(from = c(\"SE\", \"Att\"), to = \"Anx\",\n   arrows = 1, values = 0.5, labels = c(\"cprime\", \"b\"))\n\nregPaths2 <- mxPath(from = \"SE\", to = \"Att\",\n   arrows = 1, values = 0.5, labels = \"a\")\n\n## Variances\nvarPaths <- mxPath(from = names, \n   arrows = 2, values = 1, labels = c(\"eAtt\", \"vSE\", \"eAnx\"))\n\n## Means and intercepts\nmeans <- mxPath(from = \"one\", to = names,\n   arrows = 1, values = 1, labels = c(\"iAtt\", \"mSE\", \"iAnx\"))\n\n## Indirect and total effects\nindirect <- mxAlgebra(a * b, name = \"indirect\")\ntotal <- mxAlgebra(a * b + cprime, name = \"total\")\n\n## Setup the model with all the bits\nmedModel <- mxModel(model = \"Mediation\",\n   type = \"RAM\",\n   data = dataCov,\n   manifestVars = names,\n   varPaths,\n   regPaths1, regPaths2,\n   means, \n   indirect, total)\t\n\n## Run the model and get summary\nfit <- mxRun(medModel)\nsummary(fit)\n\n## Extract indirect and total effects (and their standard errors) from \"fit\" object\nestimates <- mxEval(c(indirect, total), fit); estimates\nSE <- sapply(c(\"indirect\", \"total\"), function(x) mxSE(x, fit, silent = TRUE)); SE\n\n## Get the standardised effects\n# Compare with standardised estimates in Fig 1\nmxStandardizeRAMpaths(fit)\nestZ <- mxStandardizeRAMpaths(fit)[1:3, 8]\nnames(estZ) <- mxStandardizeRAMpaths(fit)[1:3, \"label\"]; estZ\n\n# Calculate standardised effects for \"indirect\" and \"total\" by hand\nestZ[\"indirect\"] <- estZ[\"a\"] * estZ[\"b\"]\nestZ[\"total\"] <- estZ[\"indirect\"] + estZ[\"cprime\"]\nestZ\n\n## R squares - have to calculate by hand\n# For variables implicated in regressions,\n# R square is given by matrix product of:\n#   row matrix of correlations and\n#   column matrix of standardised regression coefficients\n\n# Compare with R squares given in Fig 1.\n\n# Get correlations (with names) and standardised regression coefficients\ndimnames(mcor) = list(names, names); mcor\nestZ\n\n# R Squared for SE predicting Att:\n# Correlation between Att and SE, and\n# \"a\" standardised regression coefficient\nRsqAtt = mcor[\"Att\", \"SE\"] * estZ[\"a\"]\n\n# R Squared for SE and Att predicting Anx\n# Correlations between Anx and SE, and Anx and Att\n# \"b\" and \"cprime\" standardised regression coefficients\nRsqAnx =  matrix(mcor[\"Anx\", c(\"Att\", \"SE\")], 1)  %*%\n   matrix(estZ[c(\"b\", \"cprime\")], 2)\n\n# Combine them\nRsq = matrix(c(RsqAtt, RsqAnx), \n  dimnames = list(c(\"Att\", \"Anx\"), \"R Square\"),\n  2)\nRsq\n\n## To get likelihood-based CIs\nci <- mxCI(c(\"a\", \"b\", \"cprime\", \"indirect\", \"total\"))\n\n# Add to the model\nmedModel <- mxModel(medModel, ci)\n\n# Run the model\nfit <- mxRun(medModel, intervals = TRUE)\nsummary(fit)$CI\n```\n:::\n\n\n<br/>\n \n- Little, T., Slegers, D., & Card, N. (2006). A non-arbitrary method of identifying and scaling latent variables in SEM and MACS models. *Structural Equation Modeling*, *13*(1), 59-72. <br/> Three methods of scaling (reference group, marker variable, and effects scaling) in a two-factor, two-group model. Some easier examples (one-factor model, two-factor model, one-factor two-group model) are shown [here](EasierExamples.qmd).\n\n<details class=\"image-fold\">\n  <summary>Model for Reference-Group Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/Scaling1.svg\">  \n</details> \n\n<details class=\"image-fold\">\n  <summary>Model for Marker-Variable Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/Scaling2.svg\">  \n</details> \n\n<details class=\"image-fold\">\n  <summary>Model for Effects-Scaling Method</summary>\n  <img src=\"../Drawing_SEMs/Little_2006/scaling3.svg\">  \n</details> \n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Little_Scaling.r\"}\n## Little, T., Slegers, D., & Card, N. (2006). A non-arbitrary method of\n## identifying and scaling latent variables in SEM and MACS models.\n## Structural Equation Modeling, 13(1), 59-72.\n\n## Methods of Scaling and Identification\n\n## Demonstrates three methods of scaling in two-factor, two-group model:\n## 1. Reference-group method - Constrain both latent variables' variances and means;\n## 2. Marker-variable method - Constrain one loading and that indicator's intercept in both factors;\n## 3. Effect-scaling method - Constrain sums of loadings and intercepts for both factors.\n\n## Little et al assume strong metric invariance:\n## Corresponding loadings and intercepts constrained to equality across groups\n\n## Compare with results given in Table 2 (pp. 64-65)\n## Little et al show results for three versions of Method 2.\n## Only the third is demonstrated here.\n\n## Load package\nlibrary(OpenMx)\n\n## Get the data from Appendix A\n# 7th grade\ncor7 <- c(\n   1.00000,\n   0.75854,  1.00000,\n   0.76214,  0.78705,  1.00000,\n   0.02766,  0.00973, -0.05762,  1.00000,\n  -0.06112, -0.06105, -0.14060,  0.78501,  1.00000,\n  -0.02222, -0.05180, -0.10250,  0.81616,  0.81076,  1.00000)\n\nmean7 <- c(3.13552, 2.99061, 3.06945, 1.70069, 1.52705, 1.54483)\nsd7 <- c(0.66770, 0.68506, 0.70672, 0.71418, 0.66320, 0.65276)\nn7 <- 380\n\n# 8th grade\ncor8 <- c(\n   1.00000,\n   0.81366,  1.00000,\n   0.84980,  0.83523,  1.00000,\n  -0.18804, -0.15524, -0.21520,  1.00000,\n  -0.28875, -0.24951, -0.33769,  0.78418,  1.00000,\n  -0.29342, -0.21022, -0.30553,  0.79952,  0.83156,  1.00000)\n\nmean8 <- c(3.07338, 2.84716, 2.97882, 1.71700, 1.57955, 1.55001)\nsd8 <- c(0.70299, 0.71780, 0.76208, 0.65011, 0.60168, 0.61420)\nn8 <- 379\n\n## Get the variable names from Appendix A\nnames = c(\"pos1\", \"pos2\", \"pos3\", \"neg1\", \"neg2\", \"neg3\")\n\n# Get full correlation matrix for each Grade\nmcor7 <- matrix( , 6, 6)                         # Empty matrix\nmcor7[upper.tri(mcor7, diag = TRUE)] <- cor7     # Fill the upper triangle\nmcor7 <- pmax(mcor7, t(mcor7), na.rm = TRUE)     # Fill the lower triangle\n\nmcor8 <- matrix( , 6, 6)                          # Empty matrix\nmcor8[upper.tri(mcor8, diag = TRUE)] <- cor8      # Fill the upper triangle\nmcor8 <- pmax(mcor8, t(mcor8), na.rm = TRUE)      # Fill the lower triangle\n\n# Get co/variance matrix for each grade\nmcov7 <- outer(sd7, sd7) * mcor7\nmcov8 <- outer(sd8, sd8) * mcor8\n\n# Name the rows and columns\ndimnames(mcov7) <- list(names, names)\ndimnames(mcov8) <- list(names, names)\nmcov7; mcov8\n\nnames(mean7) <- names   # OpenMx requires the means be named\nnames(mean8) <- names\n\n# Get data into OpenMx format\ndata7 <- mxData(observed = mcov7, type = \"cov\", means = mean7, numObs = n7)\ndata8 <- mxData(observed = mcov8, type = \"cov\", means = mean8, numObs = n8)\n\n\n### Meethod 1: Reference-Group Method\n## Constrain latent variances to 1\n## Constrain latent means to 0\n## These constraints apply to Grade 7 only.\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings1 <- mxPath(from = \"POS\", to = c(\"pos1\", \"pos2\", \"pos3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\nloadings2 <- mxPath(from = \"NEG\", to = c(\"neg1\", \"neg2\", \"neg3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda4\", \"lambda5\", \"lambda6\"))\n\n# Factor variances and covariance - constrain variances to 1 for Grade 7 only\nvarFac7 <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = c(FALSE, TRUE, FALSE), values = 1,\n   labels = c(\"phi7_11\", \"phi7_12\", \"phi7_22\"))\n \nvarFac8 <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = 1,\n   labels = c(\"phi8_11\", \"phi8_12\", \"phi8_22\"))\n\n# Factor means - constrain means to 0 for Grade 7 only\nmeans7 <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = FALSE, values = 0,\n   labels = c(\"kappa7_1\", \"kappa7_2\"))\n\nmeans8 <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa8_1\", \"kappa8_2\"))\n\n# Residual variances\nvarRes7 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta7_1\", \"theta7_2\", \"theta7_3\", \"theta7_4\", \"theta7_5\", \"theta7_6\"))\n\nvarRes8 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta8_1\", \"theta8_2\", \"theta8_3\", \"theta8_4\", \"theta8_5\", \"theta8_6\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\", \"tau4\", \"tau5\", \"tau6\"))\n\n## Setup models for each Grade\nmodGr7 <- mxModel(\"Grade7\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data7, loadings1, loadings2, varFac7, means7, varRes7, intercepts)\n\nmodGr8 <- mxModel(\"Grade8\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data8, loadings1, loadings2, varFac8, means8, varRes8, intercepts)\n\n## Combine the two models\nfun <- mxFitFunctionMultigroup(c(\"Grade7.fitfunction\", \"Grade8.fitfunction\"))\nmodel1 <- mxModel(\"Referemce Group Method\", modGr7, modGr8, fun)\n\n## Run the model and get summary\n# Compare with results for Method 1 in Table 2.\nfit1 <- mxRun(model1)\nsummary1 <- summary(fit1, refModels = mxRefModels(fit1, run = TRUE))\nsummary1\n\n\n### Method 2: Marker-Variable Method\n## Constrain 3rd loading in POS to 1 in both groups\n## Constrain 1st loading in NEG to 1 in both groups\n## Constrain 3rd intercept in POS to 0 in both groups\n## Constrain 1st intercept in NEG to 0 in both groups\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings - 3rd loading for POS constrained to 1\n#                 - 1st loading for NEG constrained to 1\nloadings1 <- mxPath(from = \"POS\", to = c(\"pos1\", \"pos2\", \"pos3\"), arrows = 1,\n   free = c(TRUE, TRUE, FALSE), values = c(0.5, 0.5, 1),\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\nloadings2 <- mxPath(from = \"NEG\", to = c(\"neg1\", \"neg2\", \"neg3\"), arrows = 1,\n   free = c(FALSE, TRUE, TRUE), values = c(1, 0.5, 0.5),\n   labels = c(\"lambda4\", \"lambda5\", \"lambda6\"))\n\n# Factor variances and covariance\nvarFac7 <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = 1, \n   labels = c(\"phi7_11\", \"phi7_12\", \"phi7_22\"))\n\nvarFac8 <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = 1,\n   labels = c(\"phi8_11\", \"phi8_12\", \"phi8_22\"))\n\n# Factor means\nmeans7 <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa7_1\", \"kappa7_2\"))\n\nmeans8 <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa8_1\", \"kappa8_2\"))\n\n# Residual variances\nvarRes7 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta7_1\", \"theta7_2\", \"theta7_3\", \"theta7_4\", \"theta7_5\", \"theta7_6\"))\n\nvarRes8 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"theta8_1\", \"theta8_2\", \"theta8_3\", \"theta8_4\", \"theta8_5\", \"theta8_6\"))\n\n# Intercepts - 3rd intercept for POS & 1st intercept for NEG constrained to 0\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = c(TRUE, TRUE, FALSE, FALSE, TRUE, TRUE), values = c(1, 1, 0, 0, 1, 1),\n   labels = c(\"tau1\", \"tau2\", \"tau3\", \"tau4\", \"tau5\", \"tau6\"))\n\n## Setup models for each Grade\nmodGr7 <- mxModel(\"Grade7\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data7, loadings1, loadings2, varFac7, means7, varRes7, intercepts)\n\nmodGr8 <- mxModel(\"Grade8\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data8, loadings1, loadings2, varFac8, means8, varRes8, intercepts)\n\n## Combine the two models\nfun <- mxFitFunctionMultigroup(c(\"Grade7.fitfunction\", \"Grade8.fitfunction\"))\nmodel2 <- mxModel(\"Referemce Group Method\", modGr7, modGr8, fun)\n\n## Run the model and get summary\n# Compare with results for third Method 2 in Table 2.\nfit2 <- mxRun(model2)\nsummary2 <- summary(fit2, refModels = mxRefModels(fit2, run = TRUE))\nsummary2\n\n\n### Method 3: Effects-Scaling Method\n## Constrain loadings to add to 3 in both factors for both Grades\n## Constrain intercepts to add to 0 in both factors for both Grades\n\n## Collect the bits and pieces needed by OpenMx\n# Factor loadings\nloadings1 <- mxPath(from = \"POS\", to = c(\"pos1\", \"pos2\", \"pos3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda1\", \"lambda2\", \"lambda3\"))\n\nloadings2 <- mxPath(from = \"NEG\", to = c(\"neg1\", \"neg2\", \"neg3\"), arrows = 1,\n   free = TRUE, values = 0.5,\n   labels = c(\"lambda4\", \"lambda5\", \"lambda6\"))\n\n# Factor variances and covariance\nvarFac7 <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = 1, \n   labels = c(\"phi7_11\", \"phi7_12\", \"phi7_22\"))\n\nvarFac8 <- mxPath(from = c(\"POS\", \"NEG\"), arrows = 2, connect = \"unique.pairs\",\n   free = TRUE, values = 1,\n   labels = c(\"phi8_11\", \"phi8_12\", \"phi8_22\"))\n\n# Factor means\nmeans7 <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa7_1\", \"kappa7_2\"))\n\nmeans8 <- mxPath(from = \"one\", to = c(\"POS\", \"NEG\"), arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"kappa8_1\", \"kappa8_2\"))\n\n# Residual variances\nvarRes7 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta7_1\", \"theta7_2\", \"theta7_3\", \"theta7_4\", \"theta7_5\", \"theta7_6\"))\n\nvarRes8 <- mxPath(from = names, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"theta8_1\", \"theta8_2\", \"theta8_3\", \"theta8_4\", \"theta8_5\", \"theta8_6\"))\n\n# Intercepts\nintercepts <- mxPath(from = \"one\", to = names, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"tau1\", \"tau2\", \"tau3\", \"tau4\", \"tau5\", \"tau6\"))\n\n## Setup models for each Grade\nmodGr7 <- mxModel(\"Grade7\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data7, loadings1, loadings2, varFac7, means7, varRes7, intercepts)\n\nmodGr8 <- mxModel(\"Grade8\", type = \"RAM\",\n   manifestVars = names, latentVars = c(\"POS\", \"NEG\"),\n   data8, loadings1, loadings2, varFac8, means8, varRes8, intercepts)\n\n## Constraints\nconLoad1  <- mxConstraint(lambda1 + lambda2 + lambda3 == 3)\nconLoad2  <- mxConstraint(lambda4 + lambda5 + lambda6 == 3)\nconInter1 <- mxConstraint(tau1 + tau2 + tau3 == 0)\nconInter2 <- mxConstraint(tau4 + tau5 + tau6 == 0)\n\n## Combine the two models\nfun <- mxFitFunctionMultigroup(c(\"Grade7.fitfunction\", \"Grade8.fitfunction\"))\nmodel3 <- mxModel(\"Referemce Group Method\", modGr7, modGr8,\n          conLoad1, conLoad2, conInter1, conInter2, fun)\n\n## Run the model and get summary\n# Compare with results for Method 3 in Table 2.\nfit3 <- mxRun(model3)\nsummary3 <- summary(fit3, refModels = mxRefModels(fit3, run = TRUE))\nsummary3\n\n## Get fit measures\n#  Compare with fit measures given on page 66\nmodels <- list(\n   \"Method 1\" = summary1,\n   \"Method 2\" = summary2,\n   \"Method 3\" = summary3)\n\nmeasures = c(\"Chi\", \"ChiDoF\", \"p\", \"CFI\", \"TLI\", \"RMSEA\")\n\nfit1 <- do.call(rbind, lapply(models, `[`, measures))\nfit2 <- do.call(rbind, lapply(models, `[[`, \"RMSEACI\"))\n\ncbind(fit1, fit2)\n\n## Note: RMSEA given by OpenMx does not agree with the value given by Little et al. \n#  OpenMx does not adjust RMSEA in multiple group models -\n#  see the RMSEA section in ?mxSummary for brief explanation, and\n# https://openmx.ssri.psu.edu/index.php/forums/opensem-forums/fit-functions/rmsea-multiple-group-analysis\n#  for another discussion.\n#  LISREL, lavaan, Mplus (and possibly other packages) do make the adjustment.\n\n# Equation for RMSEA, as given by Steiger (1998, Eq. 25, p. 417):\n#  RMSEA = sqrt((ChiSq/df - 1) / n)\n\n#  Substitute values from above;\n#  gives 'unadjusted RMSEA' as obtained by OpneMx.\nsqrt((58.60023/24 - 1) / 759)\n\n#  Steiger (1998, p. 417) states that 'adjusted RMSEA' can be obtained\n#  by multiplying 'unadjusted RMSEA' by sqrt(g) (where g is the number\n#  of groups).\nsqrt(2) * sqrt((58.60023/24 - 1) / 759)\n\n#  Gives 'adjusted RMSEA' as given by Little et al (ie, LISREL)\n#  and by lavaan (see 'SEMs_with_lavaan').\n\n\n# Steiger, J. (1998). A note on multiple sample extensions of the RMSEA \n# fit index. Structural Equation Modeling, 5(4), 411-419.\n```\n:::\n\n\n<br/> \n\n- Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling approaches for analyzing means. In R. Hoyle (Ed.), *Handbook of structural equation modeling* (2nd ed., pp. 385-408). New York, NY: Guilford Press. <br/>\nSEMs approaches for ANOVA and MANOVA type models.\n\n<h5>The Models</h5>\n\n<details>\n  <summary>one-way ANOVA model</summary>\n  <img src=\"../Drawing_SEMs/Green_2023/one_way_ANOVA.svg\">  \n</details> \n\n<details>\n  <summary>one-way ANCOVA model</summary>\n  <img src=\"../Drawing_SEMs/Green_2023/one_way_ANCOVA.svg\">  \n</details> \n\n<details>\n  <summary>two-way ANOVA model</summary>\n  <img src=\"../Drawing_SEMs/Green_2023/two_way_ANOVA.svg\">  \n</details> \n\n<details>\n  <summary>one-way MANOVA model</summary>\n  <img src=\"../Drawing_SEMs/Green_2023/one_way_MANOVA.svg\">  \n</details>\n \n<details>\n  <summary>one-way LATENT model</summary>\n  <img src=\"../Drawing_SEMs/Green_2023/one_way_LATENT.svg\">  \n</details> \n\n<h5>The Data</h5>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"satisfactionI.r\"}\n### Data for Tables 21.1, 21.2, 21.3, 21.4 ###\n\ndf <- structure(list(x = c(\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \n\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \n\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\"), g = c(\"m\", \"m\", \"m\", \"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \"m\", \n\"m\", \"m\", \"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \"m\", \"m\", \"m\", \"f\", \"f\", \n\"f\", \"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \n\"f\", \"f\", \"f\", \"m\", \"m\", \"m\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\"), \n    c = c(\"before\", \"before\", \"before\", \"before\", \"before\", \"before\", \n    \"before\", \"before\", \"before\", \"after\", \"after\", \"after\", \n    \"after\", \"after\", \"after\", \"after\", \"after\", \"after\", \"before\", \n    \"before\", \"before\", \"before\", \"before\", \"before\", \"after\", \n    \"after\", \"after\", \"after\", \"after\", \"after\", \"before\", \"before\", \n    \"before\", \"before\", \"before\", \"before\", \"before\", \"before\", \n    \"before\", \"after\", \"after\", \"after\", \"after\", \"after\", \"after\", \n    \"after\", \"after\", \"after\"), y = c(21, 19, 22, 21, 24, 23, \n    21, 24, 23, 22, 22, 24, 25, 27, 30, 22, 23, 24, 23, 23, 21, \n    19, 22, 21, 30, 26, 22, 25, 26, 27, 27, 25, 24, 25, 23, 22, \n    23, 28, 26, 34, 30, 26, 26, 27, 28, 29, 40, 42)), class = \"data.frame\", row.names = c(NA, \n-48L))\n\n\nhead(df)\n\n## x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n## g - Gender\n## c - before/after \n## y - dependent variable (Life Satisfaction)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"ANOVA_data.r\"}\n### Data for Tables 21.1, 21.2, 21.3, 21.4 ###\n\n## Reshape data - long to wide\ntab <- 0.5 * table(df$x)  # in each condition\ndf$id <- c(rep(1:tab[1], 2), rep(1:tab[2], 2), rep(1:tab[3], 2))  # id variable \n\ndf <- reshape(df, timevar = \"c\", idvar = c(\"id\", \"x\", \"g\"), varying = c(\"pre\", \"y\"), \n   direction = \"wide\")\n\ndf <- within(df, {\n## Grand mean centered \"pre\" - the before scores\n   preC <- scale(pre, scale = FALSE)\n\n## Drop the id variable\n   id <- NULL\n\n## Gender X Coping Strategy interaction\n  sg <- interaction(x, g, sep = \"\")\n})\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"satisfactionII.r\"}\n### Data for Tables 21.5 and 21.6 ###\n\ndf <- structure(list(x = c(\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \n\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \n\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \n\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \n\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \n\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \n\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \n\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \n\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \n\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \n\"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\", \"c\"), x1 = c(1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L), x2 = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L), x3 = c(0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, \n0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, \n1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L), y1 = c(18L, 24L, \n21L, 24L, 19L, 22L, 23L, 32L, 24L, 22L, 24L, 23L, 28L, 22L, 22L, \n23L, 19L, 28L, 25L, 25L, 27L, 21L, 33L, 24L, 23L, 28L, 29L, 24L, \n28L, 24L, 26L, 28L, 21L, 26L, 20L, 24L, 22L, 32L, 31L, 22L, 22L, \n27L, 22L, 26L, 24L, 24L, 25L, 27L, 26L, 24L, 22L, 18L, 25L, 27L, \n29L, 24L, 22L, 32L, 23L, 27L, 28L, 24L, 18L, 32L, 27L, 25L, 24L, \n25L, 29L, 21L, 29L, 25L, 25L, 25L, 19L, 32L, 29L, 22L, 18L, 26L, \n23L, 26L, 21L, 18L, 24L, 24L, 17L, 24L, 33L, 21L, 23L, 27L, 26L, \n28L, 20L, 27L, 25L, 25L, 25L, 18L, 27L, 25L, 22L, 23L, 26L, 23L, \n29L, 26L, 24L, 27L, 22L, 24L, 26L, 31L, 27L, 22L, 22L, 26L, 25L, \n21L, 26L, 25L, 24L, 26L, 28L, 27L, 26L, 26L, 19L, 22L, 25L, 26L, \n30L, 22L, 26L, 25L, 27L, 32L, 22L, 27L, 26L, 30L, 32L, 28L, 25L, \n23L, 21L, 14L, 26L, 28L, 29L, 25L, 27L, 25L, 26L, 21L, 23L, 25L, \n26L, 30L, 30L, 26L, 22L, 31L, 28L, 26L, 29L, 25L, 26L, 24L, 28L, \n22L, 35L, 26L, 34L, 29L, 26L, 27L, 32L, 16L, 26L, 22L, 25L, 30L, \n28L, 25L, 22L, 23L, 28L, 23L, 36L, 27L, 24L, 23L, 34L, 31L, 33L, \n26L, 27L, 22L), y2 = c(49L, 50L, 51L, 53L, 44L, 50L, 52L, 55L, \n53L, 48L, 48L, 51L, 57L, 51L, 48L, 51L, 48L, 53L, 59L, 55L, 51L, \n54L, 63L, 49L, 54L, 54L, 52L, 47L, 50L, 49L, 54L, 57L, 51L, 53L, \n49L, 53L, 53L, 57L, 58L, 49L, 53L, 55L, 59L, 57L, 55L, 53L, 55L, \n54L, 47L, 54L, 48L, 47L, 50L, 59L, 52L, 52L, 52L, 60L, 59L, 50L, \n55L, 59L, 55L, 59L, 61L, 48L, 55L, 55L, 60L, 50L, 62L, 54L, 56L, \n61L, 52L, 55L, 51L, 56L, 52L, 56L, 53L, 49L, 59L, 51L, 57L, 55L, \n48L, 54L, 56L, 53L, 47L, 54L, 52L, 54L, 50L, 54L, 52L, 54L, 59L, \n54L, 61L, 54L, 54L, 50L, 56L, 51L, 59L, 50L, 52L, 55L, 57L, 57L, \n62L, 55L, 53L, 51L, 50L, 60L, 51L, 52L, 52L, 56L, 52L, 55L, 56L, \n51L, 64L, 54L, 47L, 51L, 54L, 55L, 55L, 55L, 54L, 55L, 58L, 57L, \n56L, 60L, 55L, 54L, 61L, 55L, 50L, 53L, 60L, 49L, 58L, 61L, 55L, \n51L, 58L, 53L, 55L, 49L, 55L, 53L, 56L, 53L, 55L, 53L, 48L, 59L, \n56L, 52L, 55L, 58L, 54L, 54L, 59L, 49L, 60L, 62L, 57L, 59L, 57L, \n61L, 58L, 53L, 56L, 52L, 53L, 55L, 54L, 53L, 49L, 48L, 59L, 55L, \n61L, 59L, 50L, 55L, 58L, 63L, 53L, 56L, 55L, 54L), y3 = c(42L, \n42L, 46L, 39L, 39L, 37L, 38L, 43L, 36L, 37L, 40L, 45L, 46L, 39L, \n39L, 36L, 38L, 43L, 44L, 42L, 37L, 38L, 41L, 40L, 40L, 48L, 41L, \n37L, 42L, 32L, 38L, 43L, 38L, 41L, 45L, 39L, 40L, 41L, 49L, 40L, \n39L, 40L, 41L, 39L, 41L, 43L, 43L, 37L, 38L, 42L, 44L, 36L, 39L, \n44L, 41L, 38L, 40L, 49L, 41L, 39L, 46L, 45L, 40L, 50L, 45L, 43L, \n40L, 42L, 44L, 34L, 42L, 39L, 46L, 39L, 39L, 42L, 41L, 36L, 42L, \n46L, 39L, 39L, 37L, 36L, 42L, 32L, 37L, 43L, 42L, 42L, 46L, 47L, \n42L, 47L, 39L, 36L, 38L, 43L, 38L, 40L, 47L, 42L, 43L, 42L, 44L, \n42L, 45L, 41L, 39L, 45L, 42L, 41L, 46L, 44L, 43L, 38L, 42L, 44L, \n36L, 37L, 45L, 45L, 37L, 41L, 38L, 42L, 42L, 40L, 35L, 46L, 40L, \n42L, 48L, 42L, 42L, 44L, 44L, 48L, 38L, 43L, 42L, 40L, 48L, 39L, \n40L, 32L, 46L, 34L, 45L, 43L, 42L, 38L, 42L, 35L, 46L, 38L, 42L, \n39L, 43L, 43L, 50L, 41L, 42L, 43L, 44L, 35L, 44L, 42L, 41L, 47L, \n48L, 40L, 46L, 44L, 51L, 43L, 39L, 47L, 51L, 37L, 42L, 38L, 37L, \n38L, 43L, 40L, 36L, 40L, 46L, 43L, 50L, 42L, 42L, 40L, 43L, 46L, \n43L, 40L, 42L, 41L), y4 = c(29L, 31L, 34L, 36L, 26L, 30L, 34L, \n38L, 37L, 31L, 37L, 30L, 38L, 26L, 36L, 27L, 30L, 39L, 37L, 35L, \n39L, 33L, 35L, 32L, 34L, 40L, 32L, 31L, 38L, 38L, 34L, 42L, 30L, \n32L, 27L, 33L, 32L, 35L, 40L, 27L, 31L, 35L, 32L, 37L, 38L, 31L, \n29L, 28L, 33L, 35L, 31L, 22L, 34L, 37L, 27L, 33L, 35L, 47L, 30L, \n39L, 38L, 40L, 29L, 43L, 34L, 34L, 32L, 41L, 34L, 33L, 34L, 34L, \n32L, 32L, 30L, 34L, 32L, 38L, 25L, 35L, 34L, 24L, 34L, 33L, 26L, \n31L, 30L, 35L, 37L, 35L, 35L, 40L, 34L, 33L, 28L, 35L, 36L, 35L, \n40L, 34L, 39L, 33L, 28L, 34L, 31L, 29L, 39L, 40L, 35L, 37L, 36L, \n34L, 38L, 33L, 32L, 26L, 33L, 36L, 30L, 25L, 33L, 35L, 35L, 38L, \n36L, 39L, 32L, 34L, 35L, 34L, 36L, 28L, 35L, 30L, 31L, 38L, 35L, \n40L, 31L, 40L, 37L, 32L, 42L, 35L, 34L, 34L, 35L, 23L, 35L, 41L, \n39L, 37L, 34L, 26L, 35L, 34L, 35L, 33L, 31L, 40L, 38L, 32L, 29L, \n37L, 39L, 34L, 35L, 35L, 28L, 40L, 37L, 35L, 40L, 35L, 42L, 40L, \n42L, 37L, 39L, 32L, 38L, 31L, 34L, 39L, 38L, 35L, 32L, 33L, 39L, \n36L, 43L, 36L, 30L, 36L, 42L, 35L, 32L, 32L, 33L, 35L)), class = \"data.frame\", row.names = c(NA, \n-200L))\n\n\n\nhead(df)\n\n## x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n## y1, y2, y3, y4 - Multiple dependent variables (life-satisfaction scores)\n```\n:::\n\n\n<h5>R Scripts</h5>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"one_way_ANOVA.r\"}\n## One-Way ANOVA\n##\n## Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling\n## approaches for analyzing means. In R. Hoyle (Ed.), Handbook of structural\n## equation modeling (2nd ed., pp. 385-408). New York, NY: Guilford Press.\n\n# This example shows the SEM approach to a one-way ANOVA. \n# Results are presented in Table 21.1 (p. 389).\n\n# The data are discussed on page 388.\n# Data are available in \"satisfactionI.r\"\n# \"ANOVA_data.r\" rearranges the data - from \"long\" to \"wide\".\n\n# The variables used here are:\n#   x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n#   y - dependent variable (Life-Satisfaction) \n\n## Load packages\nlibrary(OpenMx)\n\n## Get the data\nsource(\"satisfactionI.r\")\nhead(df)\n\n## Rearrange the data file\nsource(\"ANOVA_data.r\")\nhead(df)\n\n## Two models:\n# \"Less Constrained\" model - means allowed to differ across the groups;\n# \"More Constrained\" model - means constrained to equality across the groups.\n# To be consistent with ANOVA's assumption of homogeneity of variances, \n# the residual variances are constrained to equality across the groups.\n\n## Get data into OpenMx format for each group\ndataA <- mxData(observed = df[df$x == \"a\", c(\"x\",\"y\")], type = \"raw\")\ndataB <- mxData(observed = df[df$x == \"b\", c(\"x\",\"y\")], type = \"raw\")\ndataC <- mxData(observed = df[df$x == \"c\", c(\"x\",\"y\")], type = \"raw\")\n\n### \"Less Constrained\" model\n## Means for each group - Means differ across the groups\nmeanA <- mxPath(from = \"one\", to = \"y\", values = 0.5, arrows = 1, label = \"a1\")\nmeanB <- mxPath(from = \"one\", to = \"y\", values = 0.5, arrows = 1, label = \"a2\")\nmeanC <- mxPath(from = \"one\", to = \"y\", values = 0.5, arrows = 1, label = \"a3\")\n   \n## Residual variances - Constrained to equality across the groups\nvar <- mxPath(from = \"y\", values = 1, arrows = 2, label = \"e\") \n\n## Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = \"y\", dataA, meanA, var)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = \"y\", dataB, meanB, var)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = \"y\", dataC, meanC, var)\n\n## Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n\n## Get the means and error variance\n## Compare with SEM results in Table 21.1\nmeansLC <- coef(fitLC)[c(\"a1\", \"a2\", \"a3\")]; meansLC\nthetaLC <- coef(fitLC)[\"e\"]; thetaLC\n\n### \"More Constrained\" model\n## Constraints\nC1 <- mxConstraint(a1 == a2)\nC2 <- mxConstraint(a2 == a3)\n\n## Add them to \"Less Constrained\" model\nmodelMC <- mxModel(modelLC, C1, C2)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n## Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\ncoef(fitMC)\n\n## Get the means and error variance\n## Compare with SEM results in Table 21.1\nmeansMC <- coef(fitMC)[c(\"a1\", \"a2\", \"a3\")]; meansMC\nthetaMC <- coef(fitMC)[\"e\"]; thetaMC\n\n## Contrast the two models, and campare with chi sq test in Table 21.1\nanova(fitMC, fitLC)\n\n## Get R square and compare with result given on page 390.\n## R square formula given in Equation 21.4 (p. 390).\nRsquare <- (thetaMC - thetaLC)/thetaMC; Rsquare\n\n## The warning message at the bottom of the summary might be disconcerting for some. \n# One way to avoid the message is not to run the reference models.\n# Without the reference models, there will be no chi sq tests, \n# but that's okay; I'm not interested in the chi squares for each separate model.\n# The model comparison is what I want, and it is still available.\n\nsummary(fitLC)\nsummary(fitMC)\nanova(fitMC, fitLC)\n\n## But where does the warning come from.\n# First, some counting of degrees of freedom.\n\n# There is 1 variable per group;\n# thus, the co/variance matrix contains (1 X 2) / 2 = 1 piece of information,\n# plus the mean; that's 2 pieces of information per group.\n# There are 3 groups, thus 6 pieces of information submitted to the model.\n\n# For the LC model, \n# 1 mean per group is estimated = 3 means, and\n# 1 variance in total (it is constrainted to equality across the groups)\n# giving 4 quantities estimated.\n\n# Resulting is 2 degrees of freedom for the LC model.\n\n# When chi squares are required, and thus when reference models are included,\n# two additional models are estimated:\n# saturated model and independence model.\n\n# The saturated model estimates means and variances, \n# but does not constrain variances to equality across the groups.\n# There are 6 quantities estimated (3 means and 3 variances),\n# leaving 0 degrees of freedom (hence the name, \"saturated\").\n# The saturated model's log likelihood is used in the chi square calculation.\n# The chi square value and df are correct (check with the values given in Table 21.1).\n\n# The independence model sets all correlations to 0, \n# and estimates just the variances.\n# But with just 1 variable, there is only 1 variance to be estimated\n# (plus the means), and as a consequence, the independence model is\n# the same as the saturated model, and indeed it generates the same\n# log likelihood as the saturated model.\n# This means that the independence model too is a perfect fit to the data.\n# This, I think, is the basis of OpenMx's complaint, and the origin of the\n# warning message. The independence model is supposed to be the\n# worst fitting model, but in this situation it ends up fitting the data\n# perfectly; that is, better, not worse, than the preferred model;\n\n# Therefore, the warning message can be safely ignored - everything is\n# correctly estimated (and an overly cautious OpenMx alerts you to the fact that\n# the preferred model fits the data worse than the independence model).\n\n\n### Relax homogeneity of variances assumption\n### The \"Less Constrained\" model\n\n## Residual variances - differ across the groups\nvarA <- mxPath(from = \"y\", arrows = 2,\n   free = TRUE, values = 1, label = \"e1\")\n\nvarB <- mxPath(from = \"y\", arrows = 2,\n   free = TRUE, values = 1, label = \"e2\")\n\nvarC <- mxPath(from = \"y\", arrows = 2,\n   free = TRUE, values = 1, label = \"e3\")\n\n## Everythiing else stays the same\n\n## Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = \"y\", dataA, meanA, varA)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = \"y\", dataB, meanB, varB)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = \"y\", dataC, meanC, varC)\n\n## Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun) \n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\ncoef(fitLC)\n\n# Note: the LC model is the same as the saturated and, in turn, the independence model.\n# All three generate the same log likelihood.\n\n## Get the means and error variances\nmeansLC <- coef(fitLC)[c(\"a1\", \"a2\", \"a3\")]; meansLC\nthetaLC <- coef(fitLC)[c(\"e1\", \"e2\", \"e3\")]; thetaLC\n\n### The \"More Constrained\" model\n## Constraints - same as before\nC1; C2\n\n## Add them to \"Less Constrained\" model\nmodelMC <- mxModel(modelLC, C1, C2)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n## Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\ncoef(fitMC)\n\n## Get the means and error variances\nmeansMC <- coef(fitMC)[c(\"a1\", \"a2\", \"a3\")]; meansMC\nthetaMC <- coef(fitMC)[c(\"e1\", \"e2\", \"e3\")]; thetaMC\n\n## Contrast the two models\nanova(fitMC, fitLC)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"one_way_ANCOVA.r\"}\n## One-Way ANCOVA\n##\n## Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling\n## approaches for analyzing means. In R. Hoyle (Ed.), Handbook of structural\n## equation modeling (2nd ed., pp. 385-408). New York, NY: Guilford Press.\n\n# This example show the SEM approach to a one-way ANCOVA.\n# Results presented in Table 21.2 (p. 393).\n\n# Means and variances for exogenous variables - the covariate (preC) - are not\n# normally included in SEM diagrams, and they are not shown in these SEM diagrams.\n# However, OpenMX requires them in its model statements.\n\n# Data are available in \"satisfactionI.r\"\n# \"ANOVA_data.r\" rearranges the data \n#   - from \"long\" to \"wide\",\n#   - centering the Pre-Life_Satisfaction scores.\n\n# The variables used here are:\n#   x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n#   y - dependent variable (Life-Satisfaction) \n#   preC - Pre-Life-Satisfaction scores centred on the grand mean\n\n## Load packages\nlibrary(OpenMx)\n\n## Get the data\nsource(\"satisfactionI.r\")\nhead(df)\n\n## Rearrange the data file\nsource(\"ANOVA_data.r\")\nhead(df)\n\n## Two models:\n# \"Less Constrained\" model - means allowed to differ across the groups;\n# \"More Constrained\" model - means constrained to equality across the groups.\n# To be consistent with ANCOVA's assumptions of homogeneity of variances,\n# and homogeneity of regression slopes,\n# the residual variances and regression slopes are constrained to equality\n# across the groups.\n\n## Get data into OpenMx format for each group\ndataA <- mxData(observed = df[df$x == \"a\", c(\"x\",\"y\", \"preC\")], type = \"raw\")\ndataB <- mxData(observed = df[df$x == \"b\", c(\"x\",\"y\", \"preC\")], type = \"raw\")\ndataC <- mxData(observed = df[df$x == \"c\", c(\"x\",\"y\", \"preC\")], type = \"raw\")\n\n### \"Less Constrained\" model\n## Means for each group - \n## \"y\" means differ across the groups.\n## The means for the covariate (\"preC\") need to be included in the model.\nmanifest <- c(\"y\", \"preC\")\nmeanA <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   values = 0.5, label = c(\"a1\", \"cov1\"))\nmeanB <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   values = 0.5, label = c(\"a2\", \"cov2\"))\nmeanC <- mxPath(from = \"one\", to = manifest, arrows = 1,\n  values = 0.5 , label = c(\"a3\", \"cov3\"))\n\n## Regression slopes - Constrained to equality across the groups\nreg <- mxPath(from = \"preC\", to = \"y\", arrows = 1,\n   values = 0.5, label = \"b\")\n\n## Variances - \n## Residual variances - Constrained to equality across the groups\n## The variances for the covariate (\"preC\") need to be included in the model\nvarA <- mxPath(from = manifest, arrows = 2,\n   values = 1, label = c(\"e\", \"cov1var\")) \n   \nvarB <- mxPath(from = manifest, arrows = 2,\n   values = 1, label = c(\"e\", \"cov2var\"))\n   \nvarC <- mxPath(from = manifest, arrows = 2,\n   values = 1, label = c(\"e\", \"cov3var\"))\n\n## Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = manifest, dataA, meanA, reg, varA)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = manifest, dataB, meanB, reg, varB)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = manifest, dataC, meanC, reg, varC)\n\n## Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA.fitfunction\", \"GrB.fitfunction\", \"GrC.fitfunction\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n\n## Get the means and error variance\n## Compare with SEM results in Table 21.2\nmeansLC <- coef(fitLC)[c(\"a1\", \"a2\", \"a3\")]; meansLC\nthetaLC <- coef(fitLC)[\"e\"]; thetaLC\n\n## Get regression slopes and compare with Table 21.2 footnote\nslopeLC <- coef(fitLC)[\"b\"]; slopeLC\n\n### \"More Constrained\" model\n## Constraints\nC1 <- mxConstraint(a1 == a2)\nC2 <- mxConstraint(a2 == a3)\n\n## Add them to \"Less Constrained\" model\nmodelMC <- mxModel(modelLC, C1, C2)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n## Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\ncoef(fitMC)\n\n## Get the means and error variance\n## Compare with SEM results in Table 21.2\nmeansMC <- coef(fitMC)[c(\"a1\", \"a2\", \"a3\")]; meansMC\nthetaMC <- coef(fitMC)[\"e\"]; thetaMC\n\n## Get regression slopes and compare with Table 21.2 footnote\nslopeMC <- coef(fitMC)[\"b\"]; slopeMC\n\n## Contrast the two models, and campare with chi sq test in Table 21.2\nanova(fitMC, fitLC)\n\n## Get R square and compare with result given on page 394.\n## R square formula given in Equation 21.9 (p. 394).\nRsquare <- (thetaMC - thetaLC)/thetaMC; Rsquare\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"two_way_ANOVA.r\"}\n## Two-Way ANOVA\n##\n## Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling\n## approaches for analyzing means. In R. Hoyle (Ed.), Handbook of structural\n## equation modeling (2nd ed., pp. 385-408). New York, NY: Guilford Press.\n\n# This example shows the SEM approach to a two-way ANOVA.\n# Results presented in Table 21.4 (p. 396).\n\n# Data are available in \"satisfactionI.r\"\n# \"ANOVA_data.r\" rearranges the data \n#   - from \"long\" to \"wide\",\n#   - sets up the Gender X Coping Strategy interaction\n\n# The variables used here are:\n#   x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n#   y - dependent variable (Life-Satisfaction) \n#   g - Gender\n#   sg - Gender X Coping Strategy interaction\n\n## Load packages\nlibrary(OpenMx)\n\n## Get the data\nsource(\"satisfactionI.r\")\nhead(df)\n\n## Rearrange the data file\nsource(\"ANOVA_data.r\")\nhead(df)\n\n## Code to get the  prelimnary results presented Table 21.3 (p. 395) \n## is not shown here\n\n## Two-way ANOVA\n# There are six groups in the model, and thus there are six means.\n# They are represented by the labels am, af, ..., cf in the model diagram.\n# The \"Less Constrained\" model allows the six means to differ. \n#\n# There are three \"More Constrained\" models to test for:\n#   Gender main effect,\n#   Coping Strategy main effect, and\n#   Gender X Coping Strategy interaction.\n# These effects can be tested for unweighted means and weighted means.\n# One page 394, TLG discuss when to use weighted and unweighted means.\n\n# To be consistent with ANOVA's assumption of homogeneity of variances,\n# the variances are constrained to equality aross the groups.\n\n# Table 21.4 (p. 396) shows the results for the test of the\n# \"Coping Strategy\" main effect for weighted means.\n# Here, tests for both main effects and the interaction\n# for weighted and unweighted means are shown.\n\n## Get data into OpenMx format for each group\ndataAM <- mxData(observed = df[df$sg == \"am\", c(\"sg\",\"y\")], type = \"raw\")\ndataAF <- mxData(observed = df[df$sg == \"af\", c(\"sg\",\"y\")], type = \"raw\")\ndataBM <- mxData(observed = df[df$sg == \"bm\", c(\"sg\",\"y\")], type = \"raw\")\ndataBF <- mxData(observed = df[df$sg == \"bf\", c(\"sg\",\"y\")], type = \"raw\")\ndataCM <- mxData(observed = df[df$sg == \"cm\", c(\"sg\",\"y\")], type = \"raw\")\ndataCF <- mxData(observed = df[df$sg == \"cf\", c(\"sg\",\"y\")], type = \"raw\")\n\n### \"Less Constrained\" model\n## Means for each group - Means differ across the groups\nmeanAM <- mxPath(from = \"one\", to = \"y\", arrows = 1, values = 0.5, label = \"am\")\nmeanAF <- mxPath(from = \"one\", to = \"y\", arrows = 1, values = 0.5, label = \"af\")\nmeanBM <- mxPath(from = \"one\", to = \"y\", arrows = 1, values = 0.5, label = \"bm\")\nmeanBF <- mxPath(from = \"one\", to = \"y\", arrows = 1, values = 0.5, label = \"bf\")\nmeanCM <- mxPath(from = \"one\", to = \"y\", arrows = 1, values = 0.5, label = \"cm\")\nmeanCF <- mxPath(from = \"one\", to = \"y\", arrows = 1, values = 0.5, label = \"cf\")\n\n## Residual variance - Constrained to equality across the groups\nvar <- mxPath(from = \"y\", arrows = 2, values = 1, label = \"e\")\n\n## Setup the group models\nmodAM <- mxModel(\"GrAM\", type = \"RAM\",\n   manifestVars = \"y\", dataAM, meanAM, var)\n\nmodAF <- mxModel(\"GrAF\", type = \"RAM\",\n   manifestVars = \"y\", dataAF, meanAF, var)\n\nmodBM <- mxModel(\"GrBM\", type = \"RAM\",\n   manifestVars = \"y\", dataBM, meanBM, var)\n\nmodBF <- mxModel(\"GrBF\", type = \"RAM\",\n   manifestVars = \"y\", dataBF, meanBF, var)\n\nmodCM <- mxModel(\"GrCM\", type = \"RAM\",\n   manifestVars = \"y\", dataCM, meanCM, var)\n\nmodCF <- mxModel(\"GrCF\", type = \"RAM\",\n   manifestVars = \"y\", dataCF, meanCF, var)\n\n## Combine the six models\nfun <- mxFitFunctionMultigroup(c(\n   \"GrAM\", \"GrAF\", \"GrBM\", \"GrBF\", \"GrCM\", \"GrCF\"))\nmodelLC <- mxModel(\"LC\", modAM, modAF, modBM, modBF, modCM, modCF, fun)\n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n\n## Get the means and error variance\n## Compare with SEM results in Table 21.4\nmeansLC <- coef(fitLC)[c(\"am\", \"bm\", \"cm\", \"af\", \"bf\", \"cf\")]; meansLC\nthetaLC <- coef(fitLC)[\"e\"]; thetaLC\n\n### Gender main effect - unweighted means\n## To test the Gender main effect (applied to unweighted means), \n## constrain the mean for males to equal the mean for females. \n## But there are three means for males and three means for females. \n## Simply constrain the sum of the three means for males to equal \n## the sum of the three means for females.\n\n## Constraint\nconGU <- mxConstraint(af + bf + cf == am + bm + cm)\n\n## Add it to \"Less Constrained\" model\nmodelGU <- mxModel(modelLC, conGU)\nmodelGU <- mxModel(modelGU, name = \"Gender Unweighted\")       # Change its name \n\n## Run the MC model and get the summary\nfitGU <- mxRun(modelGU)\nsummary(fitGU, refModels = mxRefModels(fitGU, run = TRUE))\n\n## Get the means and error variance\nmeansGU <- coef(fitGU)[c(\"am\", \"bm\", \"cm\", \"af\", \"bf\", \"cf\")]; meansGU\nthetaGU <- coef(fitGU)[\"e\"]; thetaGU\n\n## Contrast the two models\nanova(fitGU, fitLC)\n\n### Coping Strategy main effect - unweighted means\n## To test for the \"Coping Strategy\" main effect, \n## restrict the mean for \"a\" strategy to equal the mean for \"b\" strategy\n## to equal the mean for \"c\" strategy. That is, constrain \n## the sum of the two \"a\" means to equal \n## the sum of the two \"b\" means; and \n## the sum of the two \"b\" means to equal \n## the sum of the two \"c\" means.\n\n## Constraints\nconCU1 <- mxConstraint(af + am == bf + bm)\nconCU2 <- mxConstraint(af + am == cf + cm)\n\n## Add them to \"Less Constrained\" model\nmodelCU <- mxModel(modelLC, conCU1, conCU2)\nmodelCU <- mxModel(modelCU, name = \"Coping Unweighted\")       # Change its name \n\n## Run the MC model and get the summary\nfitCU <- mxRun(modelCU)\nsummary(fitCU, refModels = mxRefModels(fitCU, run = TRUE))\n\n## Get the means and error variance\nmeansCU <- coef(fitCU)[c(\"am\", \"bm\", \"cm\", \"af\", \"bf\", \"cf\")]; meansCU\nthetaCU <- coef(fitCU)[\"e\"]; thetaCU\n\n## Contrast the two models\nanova(fitCU, fitLC)\n\n### Gender main effect - weighted means\n## To test for the main effects applied to weighted means,\n## the constraints are set the same way as before except this time\n## the means are weighted in proportion to the cell frequencies.\n\n# Constraint\nfreq <- table(df$g, df$x); freq      # cell frequencies\nconGW <- mxConstraint((3*af + 3*bf + 6*cf)/12 == (6*am + 3*bm + 3*cm)/12)\n\n## Add it to \"Less Constrained\" model\nmodelGW <- mxModel(modelLC, conGW)\nmodelGW <- mxModel(modelGW, name = \"Gender Weighted\")       # Change its name\n\n## Run the MC model and get the summary\nfitGW <- mxRun(modelGW)\nsummary(fitGW, refModels = mxRefModels(fitGW, run = TRUE))\n\n## Get the means and error variance\nmeansGW <- coef(fitGW)[c(\"am\", \"bm\", \"cm\", \"af\", \"bf\", \"cf\")]; meansGW\nthetaGW <- coef(fitGW)[\"e\"]; thetaGW\n\n## Contrast the two models\nanova(fitGW, fitLC)\n\n### Coping Strategy main effect - weighted means\n# Compare with SEM section in Table 21.4\n\n## Constraints\nfreq <- table(df$g, df$x); freq      # cell frequencies\nconCW1 <- mxConstraint((3*af + 6*am)/9 == (3*bf + 3*bm)/6 )\nconCW2 <- mxConstraint((3*bf + 3*bm)/6 == (6*cf + 3*cm)/9)\n\n## Add them to \"Less Constrained\" model\nmodelCW <- mxModel(modelLC, conCW1, conCW2)\nmodelCW <- mxModel(modelCW, name = \"Coping Weighted\")       # Change its name\n\n## Run the MC model and get the summary\nfitCW <- mxRun(modelCW)\nsummary(fitCW, refModels = mxRefModels(fitCW, run = TRUE))\n\n## Get the means and error variance\n## Compare with SEM results in Table 21.4\nmeansCW <- coef(fitCW)[c(\"am\", \"bm\", \"cm\", \"af\", \"bf\", \"cf\")]; meansCW\nthetaCW <- coef(fitCW)[\"e\"]; thetaCW\n\n## Contrast the two models\nanova(fitCW, fitLC)\n\n### Gender X Coping Strategy interaction\n## To test for the Gender X Coping Strategy interaction,\n## the \"More Constrained\" model needs the means to be constrained so that\n## the difference between the mean for \"female\" and the mean for \"male\" \n## remains constant across levels of \"Coping Strategy\". That is:\n\n## the difference between \"female\" mean and \"male\" mean for the \"a\" strategy equals\n## the difference between \"female\" mean and \"male\" mean for the \"b\" strategy; and\n## the difference between \"female\" mean and \"male\" mean for the \"b\" strategy equals\n## the difference between \"female\" mean and \"male\" mean for the \"c\" strategy.\n\n## Constraints\nconI1 <- mxConstraint((af - am) == (bf - bm))\nconI2 <- mxConstraint((bf - bm) == (cf - cm))\n\n## Add them to \"Less Constrained\" model\nmodelI <- mxModel(modelLC, conI1, conI2)\nmodelI <- mxModel(modelI, name = \"Interaction\")       # Change its name\n\n## Run the MC model and get the summary\nfitI <- mxRun(modelI)\nsummary(fitI, refModels = mxRefModels(fitI, run = TRUE))\n\n## Get the means and error variance\nmeansI <- coef(fitI)[c(\"am\", \"bm\", \"cm\", \"af\", \"bf\", \"cf\")]; meansI\nthetaI <- coef(fitI)[\"e\"]; thetaI\n\n## Contrast the two models\nanova(fitI, fitLC)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"one_way_MANOVA.r\"}\n## One-way MANOVA\n##\n## Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling\n## approaches for analyzing means. In R. Hoyle (Ed.), Handbook of structural\n## equation modeling (2nd ed., pp. 385-408). New York, NY: Guilford Press.\n\n# This example shows the SEM approach to a one-way MANOVA.\n# Results presented in Table 21.5 (p. 399).\n\n# The data are discussed on page 397.\n# Data are available in \"satisfactionII.r\".\n\n# The variables used here are:\n#   x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n#   y1, y2, y3, y4 - multiple dependent variables (Life-Satisfaction)\n\n## Load packages\nlibrary(OpenMx)\n\n## Get the data\nsource(\"satisfactionII.r\")\nhead(df)\n\n## Two models:\n# \"Less Constrained\" model - means allowed to differ across the groups;\n# \"More Constrained\" model - means constrained to equality across the groups.\n# Variances and covariances are constrained to equality across the groups.\n\n## Get data into OpenMx format for each group\ndataA <- mxData(observed = df[df$x == \"a\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\ndataB <- mxData(observed = df[df$x == \"b\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\ndataC <- mxData(observed = df[df$x == \"c\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\n\n### \"Less Constrained\" model\n## Means for each group - Means differ across the groups\nmanifest <- c(\"y1\", \"y2\", \"y3\", \"y4\")\nmeanA <- mxPath(from = \"one\", to = manifest , arrows = 1,\n   values = 0.5, label = c(\"a1y1\", \"a1y2\", \"a1y3\", \"a1y4\"))\n\nmeanB <- mxPath(from = \"one\", to = manifest , arrows = 1,\n   values = 0.5, label = c(\"a2y1\", \"a2y2\", \"a2y3\", \"a2y4\"))\n\nmeanC <- mxPath(from = \"one\", to = manifest , arrows = 1,\n   values = 0.5, label = c(\"a3y1\", \"a3y2\", \"a3y3\", \"a3y4\"))\n\n## Residual variances/covariances - Constrained to equality across the groups\nvar <- mxPath(from = manifest, to = manifest, connect = \"unique.pairs\", arrows = 2,\n   values = c(\n   1, 0.5, 0.5, 0.5,\n   1, 0.5, 0.5,\n   1, 0.5,\n   1),\n   labels = \n   c(\"e1\", \"e12\", \"e13\", \"e14\",\n     \"e2\", \"e23\", \"e24\",\n\t\"e3\", \"e34\",\n\t\"e4\"))\n\n## Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = manifest, dataA, meanA, var)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = manifest, dataB, meanB, var)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = manifest, dataC, meanC, var)\n\n## Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n\n## Get the means, and compare with SEM results in Table 21.5\nmeansLC <- coef(fitLC)[grepl(\"^a\", names(coef(fitLC)))]\nmatrix(meansLC, byrow = TRUE, nrow = 3, dimnames = list(c(\"a\", \"b\", \"c\"), manifest))\n\n## Get the error SSCP matrix - compare with Table 21.5\n## error SSCP = variance/covariance matrix X sample size  \nthetaLC <- coef(fitLC)[grepl(\"^e\", names(coef(fitLC)))]; thetaLC\n\neLC <- matrix( , 4, 4)                            # Empty matrix\neLC[upper.tri(eLC, diag = TRUE)] <- thetaLC       # Fill the upper triangle\neLC <- pmax(eLC, t(eLC), na.rm = TRUE)            # Fill the lower triangle\neLC <- eLC * 200\nmatrix(eLC, 4, 4, dimnames = list(manifest, manifest))\n\n### \"More Constrained\" model\n# Constraints\nC1 <- mxConstraint(a1y1 == a2y1)\nC2 <- mxConstraint(a2y1 == a3y1)\n\nC3 <- mxConstraint(a1y2 == a2y2)\nC4 <- mxConstraint(a2y2 == a3y2)\n\nC5 <- mxConstraint(a1y3 == a2y3)\nC6 <- mxConstraint(a2y3 == a3y3)\n\nC7 <- mxConstraint(a1y4 == a2y4)\nC8 <- mxConstraint(a2y4 == a3y4)\n\n## Add them to \"Less Constrained\" model\nmodelMC <- mxModel(modelLC, C1, C2, C3, C4, C5, C6, C7, C8)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n## Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\n\n## Get the means, and compare with SEM results in Table 21.5\nmeansMC <- coef(fitMC)[grepl(\"^a\", names(coef(fitLC)))]\nmatrix(meansMC, byrow = TRUE, nrow = 3, dimnames = list(c(\"a\", \"b\", \"c\"), manifest))\n\n## Get the error SSCP matrix - Table 21.5\n## error SSCP = variance/covariance matrix X sample size\nthetaMC <- coef(fitMC)[grepl(\"^e\", names(coef(fitLC)))]; thetaMC\n\neMC <- matrix( , 4, 4)                              # Empty matrix\neMC[upper.tri(eMC, diag = TRUE)] <- thetaMC         # Fill the upper triangle\neMC <- pmax(eMC, t(eMC), na.rm = TRUE)              # Fill the lower triangle\neMC <- eMC*200\nmatrix(eMC, 4, 4, dimnames = list(manifest, manifest))\n\n## Contrast the two models, and campare with chi sq test in Table 21.5\nanova(fitLC, fitMC)\n\n\n### Relax homogeneity of variances and covariances assumption. \n### See discussion in section headed \"Avoiding OLS Assumptions for \n### ANOVA/MANOVA Designs Using SEM\" (pp. 389-401)\n### \"Less Constrained\" model\n# Variance and covariances - differ across the groups\nvarA <- mxPath(from = manifest, to = manifest, connect = \"unique.pairs\", arrows = 2,\n   values = c(\n   1, 0.5, 0.5, 0.5,\n        1, 0.5, 0.5,\n             1, 0.5,\n                  1),\n   labels = \n   c(\"e11a1\", \"e12a1\", \"e13a1\", \"e14a1\",\n              \"e22a1\", \"e23a1\", \"e24a1\",\n\t                  \"e33a1\", \"e34a1\",\n\t                           \"e44a1\"))\n\nvarB <- mxPath(from = manifest, to = manifest, connect = \"unique.pairs\", arrows = 2,\n   values = c(\n   1, 0.5, 0.5, 0.5,\n   1, 0.5, 0.5,\n   1, 0.5,\n   1),\n   labels = \n   c(\"e11a2\", \"e12a2\", \"e13a2\", \"e14a2\",\n     \"e22a2\", \"e23a2\", \"e24a2\",\n\t\"e33a2\", \"e34a2\",\n\t\"e44a2\"))\n\nvarC <- mxPath(from = manifest, to = manifest, connect = \"unique.pairs\", arrows = 2,\n   values = c(\n   1, 0.5, 0.5, 0.5,\n   1, 0.5, 0.5,\n   1, 0.5,\n   1),\n   labels = \n   c(\"e11a3\", \"e12a3\", \"e13a3\", \"e14a3\",\n     \"e22a3\", \"e23a3\", \"e24a3\",\n\t\"e33a3\", \"e34a3\",\n\t\"e44a3\"))\n\n## Everything else stays the same\n\n## Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = manifest, dataA, meanA, varA)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = manifest, dataB, meanB, varB)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = manifest, dataC, meanC, varC)\n\n## Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n\n## Get the means\nmeansLC = coef(fitLC)[grepl(\"^a\", names(coef(fitLC)))]\nmatrix(meansLC, byrow = TRUE, nrow = 3, dimnames = list(c(\"a\", \"b\", \"c\"), manifest))\n\n## Get variance/covariance matrix\nthetaLC = coef(fitLC)[grepl(\"^e\", names(coef(fitLC)))]; thetaLC\n\n### \"More Constrained\" model\n## Constraints - same as before\nC1; C2; C3; C4; C5; C6; C7; C8\n\n## Add them to less constrained model\nmodelMC <- mxModel(modelLC, C1, C2, C3, C4, C5, C6, C7, C8)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n## Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\n\n## Get the means\nmeansMC <- coef(fitMC)[grepl(\"^a\", names(coef(fitLC)))]\nmatrix(meansMC, byrow = TRUE, nrow = 3, dimnames = list(c(\"a\", \"b\", \"c\"), manifest))\n\n## Get the variance/covariance matrix\nthetaMC <- coef(fitMC)[grepl(\"^e\", names(coef(fitLC)))]; thetaMC\n\n## Contrast the two models, and campare with chi sq test on page 401\nanova(fitLC, fitMC)\n\n\n\n#### lavaan\nlibrary(lavaan)\n\n# Variances and covariances (for both models)\nvcov <- \"\n   y1 ~~ y1 + y2 + y3 + y4\n   y2 ~~ y2 + y3 + y4\n   y3 ~~ y3 + y4\n   y4 ~~ y4\"\n\nmodels <- list(\n\n\"Less Constrained\" =  c(\n# Means\n   \"y1 ~ c(a1, b1, c1)*1\n    y2 ~ c(a2, b2, c2)*1\n    y3 ~ c(a3, b3, c3)*1\n    y4 ~ c(a4, b4, c4)*1\",\n\t\n    vcov),\n\n\"More Constrained\" = c(\n# Means\n   \"y1 ~ c(a1, a1, a1)*1\n    y2 ~ c(a2, a2, a2)*1\n    y3 ~ c(a3, a3, a3)*1\n    y4 ~ c(a4, a4, a4)*1\",\n\t\n\tvcov)\n)\n\n# Fit the models \nfit <- lapply(models, sem, data = df, group = \"x\")\n\n# Get model summaries\nlapply(fit, summary)[[1]]\n\n# Contrast model fits\nReduce(anova, fit)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"one_way_LATENT.r\"}\n## One-way ANOVA of latent variable\n##\n## Thompson, M., Lie, Y. & Green, S. (2023). Flexible structural equation modeling\n## approaches for analyzing means. In R. Hoyle (Ed.), Handbook of structural\n## equation modeling (2nd ed., pp. 385-408). New York, NY: Guilford Press.\n\n# This example shows the SEM approach to a one-way ANOVA of latent means.\n# Results presented in Table 21.6 (p. 404).\n\n# Data are available in \"satisfactionII.r\".\n\n# The variables used here are:\n#   x - Coping Strategy (a - No strategy; b - Discussion; c - Exercise)\n#   y1, y2, y3, y4 - multiple dependent variables (Life-Satisfaction) \n\n## Load packages\nlibrary(OpenMx)\n\n## Get the data\nsource(\"satisfactionII.r\")\nhead(df)\n\n## Comparisons of latent means assume some level of measurement invariance.\n# Thompson, Lie, and Green (TLG) assume strict measurement invariance:\n# loadings, intercepts, and residual variances and covariances are constrainted\n# to equality across the groups (covariances are zero, and thus they are equal).\n# TLG also constrain the latent error variance to equality across the groups.\n\n# Latent variables require constraints for the purposes of identification and scaling.\n# TLG claim the loading for the 4th indicator is constrained to 1,\n# but I think that is a typo. TLG constrain the loading of the 1st indicator to 1,\n# and because of measurement invariance, this constraint applies to all groups.\n# Also, TLG constrain the latent mean to 0 in the first group only.\n\n## Two models:\n# \"Less Constrained\" model - latent means are freely estimated in the other two groups;\n# \"More Constrained\" model - latent means constrained to equality across the groups;\n# that is, they are all constrained to 0.\n\n## Get data into OpenMx format for each group\ndataA <- mxData(observed = df[df$x == \"a\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\ndataB <- mxData(observed = df[df$x == \"b\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\ndataC <- mxData(observed = df[df$x == \"c\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\n\n### \"Less Constrained\" model\n# Factor loadings - equal across groups\nmanifest <- c(\"y1\", \"y2\", \"y3\", \"y4\")\nloadings <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(FALSE, TRUE, TRUE, TRUE), values = 1,   # First loading constrained to 1\n   labels = c(\"l1\", \"l2\", \"l3\", \"l4\"))\n\n## Factor variances - equal across groups\nvarFac <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"d\")\n\n## Residual variances - equal across groups\nvarRes <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"e1\", \"e2\", \"e3\", \"e4\"))\n\n## Intercepts - equal across groups\nintercepts <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1\", \"t2\", \"t3\", \"t4\"))\n\n## Factor means - differs across the groups\nmeanA <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = FALSE, values = 0, labels = \"a1\")\nmeanB <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"a2\")\nmeanC <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"a3\")\n\n## Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataA, loadings, varFac, varRes, intercepts, meanA)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataB, loadings, varFac, varRes, intercepts, meanB)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataC, loadings, varFac, varRes, intercepts, meanC)\n\n## Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n## Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n\n## Trouble!! \n## Try letting OpenMx select starting values\nmodelLC = mxAutoStart(modelLC)\n\n## Try again\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n## All good\n\n## Get latent means and variance, and compare with \"All measures\" row in Table 21.6\nestimates <- coef(fitLC)\n\nlatentMeans = coef(fitLC)[c(\"a2\", \"a3\")]; latentMeans\nlatentVar = coef(fitLC)[\"d\"]; latentVar\n\n### \"More Constrained\" model\n## Constraints\nC1 <- mxConstraint(a2 == 0)\nC2 <- mxConstraint(a3 == 0)\n\n## Add them to \"Less Constrained\" model\nmodelMC <- mxModel(modelLC, C1, C2)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n## Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\n\n## Contrast the two models, and campare with chi sq test in Table 21.6\nanova(fitLC, fitMC)\n\n## Effect sizes, and compare with values on p. 405\n# Cut-and-paste means and variances to get effect sizes\nd1 <- (0.6638 - 0) / sqrt(8.1346); d1    # \"no strategy\" vs \"discussion\"\nd2 <- (1.9446 - 0) / sqrt(8.1346); d2    # \"no strategy\" vs \"exercise\"\n\n## Better - extract latent means and error variances from \"Less Constrained\" model\n## Already extracted above\nd1 <- (latentMeans[1] - 0) / sqrt(latentVar); d1   # \"no strategy\" vs \"discussion\"\nd2 <- (latentMeans[2] - 0) / sqrt(latentVar); d2   # \"no strategy\" vs \"exercise\"\n\n\n#### Minimal constraints\n# This section applies to the 2nd and 3rd rows in Table 21.6.\n# And see the discussion at the end of page 406, and top of page 407.\n\n## Get data into OpenMx format for each group\ndataA <- mxData(observed = df[df$x == \"a\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\ndataB <- mxData(observed = df[df$x == \"b\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\ndataC <- mxData(observed = df[df$x == \"c\", c(\"x\", \"y1\", \"y2\", \"y3\", \"y4\")], type = \"raw\")\n\n\n### ANOVA model for 2nd row in Table 21.6\n# Constrain 1st loading only to equality across groups\n# and constrain 1st intercept only to equality across groups.\n\n## \"Less Constrained\" model\n\nmanifest <- c(\"y1\", \"y2\", \"y3\", \"y4\")\n\n# Factor loadings - 1st loading constrained to 1\n#                 - other loadings freely estimated across groups\nloadsA <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(FALSE, TRUE, TRUE, TRUE), values = 1,\n   labels = c(\"l1\", \"l2A\", \"l3A\", \"l4A\"))\n\nloadsB <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(FALSE, TRUE, TRUE, TRUE), values = 1,\n   labels = c(\"l1\", \"l2B\", \"l3B\", \"l4B\"))\n\nloadsC <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(FALSE, TRUE, TRUE, TRUE), values = 1,\n   labels = c(\"l1\", \"l2C\", \"l3C\", \"l4C\"))\n\n# Factor variances - freely estimated across groups\t\nvarFacA <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"dA\")\n\nvarFacB <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"dB\")\n\nvarFacC <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"dC\")\n\n# Residual variances - freely estimated across groups\nvarResA <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"e1A\", \"e2A\", \"e3A\", \"e4A\"))\n\nvarResB <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"e1B\", \"e2B\", \"e3B\", \"e4B\"))\n\nvarResC <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1,\n   labels = c(\"e1C\", \"e2C\", \"e3C\", \"e4C\"))\n\n# Intercepts - 1st intercept constrained to equality across groups\n#            - other intercepts freely estimated across groups\ninterceptsA <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1\", \"t2A\", \"t3A\", \"t4A\"))\n\ninterceptsB <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1\", \"t2B\", \"t3B\", \"t4B\"))\n\ninterceptsC <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1\", \"t2C\", \"t3C\", \"t4C\"))\n\n# Factor means - differ across the groups\nmeanA <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = FALSE, values = 0, labels = \"aA\")\nmeanB <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"aB\")\nmeanC <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"aC\")\n\n# Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataA, loadsA, varFacA, varResA, interceptsA, meanA)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataB, loadsB, varFacB, varResB, interceptsB, meanB)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataC, loadsC, varFacC, varResC, interceptsC, meanC)\n\n# Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n# Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\n\n# Again trouble, but let OpenMx choose starting values\nmodelLC = mxAutoStart(modelLC)\n\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n# All good\n\n## More Consttained model\n# Constraints\nC1 = mxConstraint(aB == 0)\nC2 = mxConstraint(aC == 0)\n\n# Add them to less constrained model\nmodelMC = mxModel(modelLC, C1, C2)\nmodelMC = mxModel(modelMC, name = \"MC\")       # Change its name\n\n# Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\n\n## Contrast the two models, and campare with chi sq test in 2dn row in Table 21.6\nanova(fitLC, fitMC)\n\n## Get latent means and variances, and compare with \"All measures\" row in Table 21.6\nestimates <- coef(fitLC)\n\nlatentMeans <- coef(fitLC)[c(\"aB\", \"aC\")]; latentMeans\nlatentVar <- coef(fitLC)[c(\"dA\", \"dB\", \"dC\")]; latentVar\n\n\n## Section of Table 21.6 headed \"Results for measures with invariant parameters\"\n# Sample statistics - get means and variances of 1st indicator for the 3 groups\ndfY1 <- split(df$y1, df$x)\nmeansY1 <- do.call(cbind, lapply(dfY1, mean)); meansY1\nvarY1 <- do.call(cbind, lapply(dfY1, var)); varY1\n\n# Note: means agree with means in Table 21.6, but variances don't.\n# To get TLG variances, the denominator in the variance formula needs to be n, not (n-1)\n\n# Get the n's\nn <- do.call(cbind, lapply(dfY1, length)); n\n\n# Adjust variance calculation\nvarY1 <- varY1 * (n - 1) / n; varY1   # All good\n\n\n# Differences between y1 means\nmeansY1[2] - meansY1[1]\nmeansY1[3] - meansY1[1]\n\n# These equal the latent means; compare with latent means\nlatentMeans\n\n# Alternatively, the y1 intercepts (which are constrained to equality)\n# added to the latent means give the y1 Means\nintercepts <- coef(fitLC)[\"t1\"]; intercepts\nintercepts + latentMeans; meansY1\n\n\n# Extract residual variances for y1 from estimates\nresidVarY1 <- coef(fitLC)[c(\"e1A\", \"e1B\", \"e1C\")]   # Compare with 2nd row in Table 21.6\n\n# Differences between y1 variances and y1 residual variances\nvarY1 - residVarY1\n\n# These are latent variances - Compare with the latent variances\nlatentVar\n\n\n\n\n## ANOVA model for 3rd row in Table 21.6\n# Constrain 2nd loading to equality across groups\n# and constrain 2nd intercept to equality across groups\n\n## \"Less Constrained\" model\n\nmanifest <- c(\"y1\", \"y2\", \"y3\", \"y4\")\n\n# Factor loadings\nloadsA <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(TRUE, FALSE, TRUE, TRUE), values = 1,\n   labels = c(\"l1A\", \"l2\", \"l3A\", \"l4A\"))\n\nloadsB <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(TRUE, FALSE, TRUE, TRUE), values = 1,\n   labels = c(\"l1B\", \"l2\", \"l3B\", \"l4B\"))\n\nloadsC <- mxPath(from = \"LS\", to = manifest, arrows = 1,\n   free = c(TRUE, FALSE, TRUE, TRUE), values = 1,\n   labels = c(\"l1C\", \"l2\", \"l3C\", \"l4C\"))\n\n# Factor variances - equal across groups\nvarFacA <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"dA\")\n\nvarFacB <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"dB\")\n\nvarFacC <- mxPath(from = \"LS\", arrows = 2,\n   free = TRUE, values = 1, labels = \"dC\")\n\n# Residual variances - equal across groups\nvarResA <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"e1A\", \"e2A\", \"e3A\", \"e4A\"))\n\nvarResB <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"e1B\", \"e2B\", \"e3B\", \"e4B\"))\n\nvarResC <- mxPath(from = manifest, arrows = 2,\n   free = TRUE, values = 1, \n   labels = c(\"e1C\", \"e2C\", \"e3C\", \"e4C\"))\n\n# Intercepts - equal across groups\ninterceptsA <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1A\", \"t2\", \"t3A\", \"t4A\"))\n\ninterceptsB <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1B\", \"t2\", \"t3B\", \"t4B\"))\n\ninterceptsC <- mxPath(from = \"one\", to = manifest, arrows = 1,\n   free = TRUE, values = 1,\n   labels = c(\"t1C\", \"t2\", \"t3C\", \"t4C\"))\n\n# Factor mean - differ across the groups\nmeanA <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = FALSE, values = 0, labels = \"aA\")\nmeanB <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"aB\")\nmeanC <- mxPath(from = \"one\", to = \"LS\", arrows = 1,\n   free = TRUE, values = 1, labels = \"aC\")\n\n# Setup the group models\nmodA <- mxModel(\"GrA\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataA, loadsA, varFacA, varResA, interceptsA, meanA)\n\nmodB <- mxModel(\"GrB\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataB, loadsB, varFacB, varResB, interceptsB, meanB)\n\nmodC <- mxModel(\"GrC\", type = \"RAM\",\n   manifestVars = manifest, latentVars = \"LS\",\n   dataC, loadsC, varFacC, varResC, interceptsC, meanC)\n\n# Combine the three models\nfun <- mxFitFunctionMultigroup(c(\"GrA\", \"GrB\", \"GrC\"))\nmodelLC <- mxModel(\"LC\", modA, modB, modC, fun)\n\n# Run the LC model and get the summary\nfitLC <- mxRun(modelLC)\n\n# Again, let OpenMx choose starting values\nmodelLC = mxAutoStart(modelLC)\n\nfitLC <- mxRun(modelLC)\nsummary(fitLC, refModels = mxRefModels(fitLC, run = TRUE))\n# All good\n\n## More Consttained model\n# Constraints\nC1 <- mxConstraint(aB == 0)\nC2 <- mxConstraint(aC == 0)\n\n# Add them to less constrained model\nmodelMC <- mxModel(modelLC, C1, C2)\nmodelMC <- mxModel(modelMC, name = \"MC\")       # Change its name \n\n# Run the MC model and get the summary\nfitMC <- mxRun(modelMC)\nsummary(fitMC, refModels = mxRefModels(fitMC, run = TRUE))\n\n## Contrast the two models, and campare with chi sq test in 2nd row in Table 21.6\nanova(fitLC, fitMC)\n\n## Get latent means and variance, and compare with \"All measures\" row in Table 21.6\nestimates <- coef(fitLC)\n\nlatentMeans <- coef(fitLC)[c(\"aB\", \"aC\")]; latentMeans\nlatentVar <- coef(fitLC)[c(\"dA\", \"dB\", \"dC\")]; latentVar\n\n\n## Section of Table 21.6 headed \"Results for measures with invariant parameters\"\n# Sample statistics - get means and variances of 1st indicator for the 3 groups\ndfY2 <- split(df$y2, df$x)\nmeansY2 <- do.call(cbind, lapply(dfY2, mean)); meansY2\nvarY2 <- do.call(cbind, lapply(dfY2, var)); varY2\n\nn <- do.call(cbind, lapply(dfY2, length)); n\n\n# Adjust variance calculation\nvarY2 <- varY2 * (n - 1) / n; varY2   # All good\n\n# Differences between y1 means\nmeansY2[2] - meansY2[1]\nmeansY2[3] - meansY2[1]\n\n# These equal the latent means; compare with latent means\nlatentMeans\n\n# Alternatively, the y1 intercepts (which are constrained to equality)\n# added to the latent means give the y2 Means\nintercepts <- coef(fitLC)[\"t2\"]; intercepts\nintercepts + latentMeans; meansY2\n\n# Extract residual variances for y1 from estimates\nresidVarY2 <- coef(fitLC)[c(\"e2A\", \"e2B\", \"e2C\")]   # Compare with 2nd row in Table 21.6\n\n# Differences between y2 variances and y2 residual variances\nvarY2 - residVarY2\n\n# These are the latent variances - Compare with the latent variances\nlatentVar\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}