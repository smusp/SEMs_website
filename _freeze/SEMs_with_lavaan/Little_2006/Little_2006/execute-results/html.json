{
  "hash": "c41632348d1b1f0af385f1da86d59e82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Scaling\"\nsubtitle: \"Scaling and identifying latent variables\"\nhighlight-style: solarized\n\nembed-resources: true\n\nexecute:\n  eval: false\n---\n\n\n::: {.cell}\n\n:::\n\n\nLittle, T., Slegers, D., & Card, N. (2006). A non-arbitrary method of identifying and scaling latent variables in SEM and MACS models. *Structural Equation Modeling*, *13*(1), 59-72.\n\nThis example shows how to set constraints for different methods of identification and scaling in latent variable models, and, though invariance is not a topic of discussion, the example shows how to set constraints for strong metric invariance in a two-group model. Also, the example shows how to use summary data (correlations, standard deviations, and means) in a two-group model.\n\nThe methods of identification and scaling discussed by Little, Slegers & Card (LS&C) are:\n\n  - Reference Group Method - For each construct, the latent variance is fixed to one and the latent mean is fixed to zero in the first group. With strong metric invariance (invariance of loadings and intercepts), latent means and variances are freely estimated in subsequent groups.\n  - Marker Variable Method - For each construct, the loading of one indicator is fixed to one, and the intercept for the chosen indicator is fixed to zero. With strong metric invariance, these constraints apply in both groups.\n  - Effects Coding Method - For each construct, constrain loadings to add to the number of indicators, and constrain indicator intercepts to add to zero. With strong metric invariance, these constraints apply in both groups.\n\nLS&C present a two-group (7th grade and 8th grade), two-construct (positive affect and negative affact) model. Each construct is assessed with three manifest indicators. The SEM diagram below shows the model as it might apply to the whole sample (i.e., ignoring the groups). This one-group model is presented to explain the symbols used in the paper, and to show how they apply in the model diagrams. First, POS and NEG are the constructs; and pos~1~, ..., neg~3~ are the manifest indicators. The solid lines represent the covariance structure, and the gray lines represent the mean structure (ie, the means and intercepts).\n\nThe symbols are:\n\n - $\\uplambda$ - loadings\n - $\\upphi$ - latent variances and covariance\n - $\\uptheta$ - indicator residual variances\n - $\\upkappa$ - latent means\n - $\\uptau$ - indicator intercepts\n\n![](../../Drawing_SEMs/Little_2006/Scaling.svg){fig-align=\"center\"}\n\n\n#### Load relevant packages\n\nLoad the **lavaan** package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lavaan)\n```\n:::\n\n\n\n#### Get the data\n\nLISREL script in Appendix A (pp. 71-72) gives correlations, standard deviations, means, and sample sizes for each group. From these, the co/variance matrices for each group can be obtained. The means, standard deviations, and correlations are entered as vectors. In Appendix A, only the lower triangle of correlations is presented with ones along the diagonal; and that is all that is needed here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 7th grade\ncor7 <- c(\n   1.00000,\n   0.75854,  1.00000,\n   0.76214,  0.78705,  1.00000,\n   0.02766,  0.00973, -0.05762,  1.00000,\n  -0.06112, -0.06105, -0.14060,  0.78501,  1.00000,\n  -0.02222, -0.05180, -0.10250,  0.81616,  0.81076,  1.00000)\n\nmean7 <- c(3.13552, 2.99061, 3.06945, 1.70069, 1.52705, 1.54483)\nsd7   <- c(0.66770, 0.68506, 0.70672, 0.71418, 0.66320, 0.65276)\nn7    <- 380\n\n# 8th grade\ncor8 <- c(\n   1.00000,\n   0.81366,  1.00000,\n   0.84980,  0.83523,  1.00000,\n  -0.18804, -0.15524, -0.21520,  1.00000,\n  -0.28875, -0.24951, -0.33769,  0.78418,  1.00000,\n  -0.29342, -0.21022, -0.30553,  0.79952,  0.83156,  1.00000)\n\nmean8 <- c(3.07338, 2.84716, 2.97882, 1.71700, 1.57955, 1.55001)\nsd8   <- c(0.70299, 0.71780, 0.76208, 0.65011, 0.60168, 0.61420)\nn8    <- 379\n```\n:::\n\n\nVariable names are also contained in the LISREL script, but I shorten the names a little.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"pos1\", \"pos2\", \"pos3\", \"neg1\", \"neg2\", \"neg3\")\n```\n:::\n\n\nCombine the correlations, means, and sample sizes into lists.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor  <- list(\"Grade 7\" = cor7, \"Grade 8\" = cor8)\nsd   <- list(sd7, sd8)\nmean <- list(mean7, mean8)\nn    <- list(n7, n8)\n```\n:::\n\n\nUse the `getCov()` function from the **lavaan** package to obtain the full co/variance matrix for each group (using the `Map()` function to apply the `getCov()` function to the lists, and to return the two co/variance matrices in a list).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncov <- Map(getCov, x = cor, sds = sd, names = list(names, names))\n```\n:::\n\n\n\n## Reference-Group Method\n\n#### The model\n\nThe model with the constraints is shown below. Some points to note. There are two groups: Grade 7 and Grade 8. The corresponding loadings ($\\uplambda$) and intercepts ($\\uptau$) are equal across the groups. The latent variances (<span style=\"white-space: nowrap\">$\\upphi$~7,11~</span> and <span style=\"white-space: nowrap\">$\\upphi$~7,22~)</span> and latent means ($\\upkappa$) are constrained to 1 and 0 respectively in the first group only. The residual variances ($\\uptheta$) are freely estimated in each group, and the latent covariances (<span style=\"white-space: nowrap\">$\\upphi$~7,12~</span> and <span style=\"white-space: nowrap\">$\\upphi$~8,12~)</span> are freely estimated. \n\n![](../../Drawing_SEMs/Little_2006/Scaling1.svg){fig-align=\"center\"}\n\nWhen constructing the model statment, there are some points to be considered.\n\nFirst, the constraints applied to latent means and variances apply in the first group only. In the model statement, pre-multiply the mean or the variance by a vector containing the constraints; like this: `c(1,NA)` - the `1` forces the parameter in the first group to be constrained to 1; the `NA` forces the parameter in the second group to be estimated.\n\nSecond, LS&C state that the data display strong metric invariance (p. 63); that is, the corresponding loadings and intercepts are equal across the groups. There is no need to be concerned with these constraints when constructing the model statement - they will be set up in the next step. (Strictly, the intercepts do not even need to be mentioned in the model statement - **lavaan** will add them automatically when `sample.means` are in the model. But they are left in the statement below because intercepts are implicated in constraints in models to follow.)\n\nThird, strong metric invariance places no constraints on indicator variances - they are freely estimated in each group. But again, there is no need to be concerned with or even to mention them when constructing the model statement - **lavaan** will add them automatically.\n\nFinally, **lavaan**'s default marker-variable method has to be explicitely disabled by pre-multiplying the first indicator for both constructs by `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <- \"\n  # Measurement Model\n  #   - Free the 1st loading so it can be estimated\n  POS =~ NA*pos1 + pos2 + pos3\n  NEG =~ NA*neg1 + neg2 + neg3\n\n  # Latent variances and covariance\n  #   - Constrain latent variances to 1 in first group\n  POS ~~ c(1,NA)*POS\n  NEG ~~ c(1,NA)*NEG\n  POS ~~ NEG\n\n  # Indicator intercepts\n  pos1 ~ 1\n  pos2 ~ 1\n  pos3 ~ 1\n  neg1 ~ 1\n  neg2 ~ 1\n  neg3 ~ 1\n\n  # Latent means\n  #   - Constrain latent means to 0 in first group\n  POS ~ c(0,NA)*1\n  NEG ~ c(0,NA)*1\n\"\n```\n:::\n\n\n\n#### Fit the model and get the results\n\nTo deal with strong metric invariance, set `group.equal = c(\"loadings\", \"intercepts\")` in the `sem()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1_fit <- sem(m1, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m1_fit, standardized = TRUE, fit.measures = TRUE)\n```\n:::\n\n\nCompare the output with \"Method 1\" in Table 2 (pp. 64-65).\n\n\n#### A shortcut\n\n**Lavaan** can do reference-group scaling automatically - set `std.lv = TRUE` in the `sem()` function. The constraints are the same as above - in the first group, latent variances are constrained to one, and latent means are constrained to zero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1_short <- \"\n  # Measurement Model\n  POS =~ pos1 + pos2 + pos3\n  NEG =~ neg1 + neg2 + neg3\n\"\n\nm1_short_fit <- sem(m1_short, sample.cov = cov, sample.nobs = n, \n   sample.mean = mean, std.lv = TRUE,\n   group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m1_short_fit, standardized = TRUE, fit.measures = TRUE)\n```\n:::\n\n\nCheck the output. It is the same as before except for one detail. It might be disconcerting for some that the latent means in the first group are not reported. Maybe it's not important because they are zero (remember the constraint). To see them in the output, set `remove.unused = FALSE` in the `summary()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(m1_short_fit, remove.unused = FALSE, standardized = TRUE,\n   fit.measures = TRUE)\n```\n:::\n\n\n\n## Marker-Variable Method\n\n#### The model\n\nThe model with the constraints is shown below.\n\n![](../../Drawing_SEMs/Little_2006/Scaling2.svg){fig-align=\"center\"}\n\nResults for three versions of Method 2 are presented in Table 2 - in each case, constraints are applied to different indicator variables. Here, only the third is considered - constraints apply to loadings and intercepts for the third indicator in the POS construct, and to the first indicator in the NEG construct.\n\nSome points to be considered.\n\nFirst, with strong metric invariance in place, the constraints applying to intercepts and loadings apply in both groups. In the model statement, pre-multiply the loadings by `c(1,1)`, and the intercepts by `c(0,0)`.\n\nSecond, again, the point concerning strong metric invariance - it will be set up in the next step.\n\nThird, again, there is no need to mention indicator variances - **lavaan** will add them automatically.\n\nFinally, **lavaan**'s default marker-variable method has to be explicitely disabled for the POS construct by pre-multiplying the first indicator be `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2c <- \"\n  # Measurement Model\n  #   - Free the 1st loading in POS so it can be estimated\n  #   - Constrain 3rd loading in POS to 1 in both groups\n  #   - Constrain 1st loading in NEG to 1 in both groups\n  POS =~ NA*pos1 + pos2 + c(1,1)*pos3\n  NEG =~ c(1,1)*neg1 + neg2 + neg3\n\n  # Latent variances and covariance\n  POS ~~ POS\n  NEG ~~ NEG\n  POS ~~ NEG\n\n  # Indicator intercepts\n  #   - Constrain 3rd intercept in POS to 0 in both groups\n  #   - Constrain 1st intercept in NEG to 0 in both groups\n  pos1 ~ 1\n  pos2 ~ 1\n  pos3 ~ c(0,0)*1\n  neg1 ~ c(0,0)*1\n  neg2 ~ 1\n  neg3 ~ 1\n\n  # Latent means\n  POS ~ 1\n  NEG ~ 1\n\"\n```\n:::\n\n\n\n#### Fit the model and get the results\n\nAs before, the `group.equal = c(\"loadings\", \"intercepts\")` statement in the `sem()` function forces corresponding loadings and intercepts to be equal across the groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2c_fit <- sem(m2c, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m2c_fit, standardized = TRUE, fit.measures = TRUE)\n```\n:::\n\n\nCompare the output with \"Method 2c\" in Table 2 (pp. 64-65).\n\n\n#### **Lavaan** default\n\nThis is not **lavaan**'s default method of scaling. The default method constrains the loadings for the first indicator to one for both constructs and, because of the strong metric invariance, in both groups. When there is a mean structure in the model, **lavaan** sets the latent means to zero (in the first group only). In the `summary()` function set `remove.unused = FALSE` to see the latent means.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2c_default <- \"\n  # Measurement Model\n  POS =~ pos1 + pos2 + pos3\n  NEG =~ neg1 + neg2 + neg3\n\"\n\nm2c_default_fit <- sem(m2c_default, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m2c_default_fit, remove.unused = FALSE,\n   standardized = TRUE, fit.measures = TRUE)\n```\n:::\n\n\n\n## Effects-Coding Method\n\n#### The model\n\nThe model with the equality constraints is shown below.\n\n![](../../Drawing_SEMs/Little_2006/Scaling3.svg){fig-align=\"center\"}\n\nIn the model statement, the loadings and the intercepts are labelled (see the \"Measurement Model\" and the \"Indicator intercepts\" sections in the model statement) so that the labels can be used to impose the constraints. Constraints are imposed on the loadings and the intercepts using the `==` operator - see the \"Constraints\" section in the model statement.\n\nSame points as before: **lavaan** will add indicator variances automatically; constraints concerning strong metric invariance will be attended to in the next step; and the default marker-variable method has to be explicitely disabled.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3 <- \"\n  # Measurement Model\n  #   - Free the 1st loading so it can be estimated\n  #   - Label the loadings so they can be used in the constraints\n  POS =~ NA*p1*pos1 + p2*pos2 + p3*pos3\n  NEG =~ NA*n1*neg1 + n2*neg2 + n3*neg3\n\n  # Latent variances and covariance\n  POS ~~ POS\n  NEG ~~ NEG\n  POS ~~ NEG\n\n  # Indicator intercepts\n  #   - Label the intercepts so they can be used in the constraints\n  pos1 ~ ip1*1\n  pos2 ~ ip2*1\n  pos3 ~ ip3*1\n  neg1 ~ in1*1\n  neg2 ~ in2*1\n  neg3 ~ in3*1\n\n  # Latent means\n  POS ~ 1\n  NEG ~ 1\n\n  # Constraints\n  # For each construct:\n  #   The sum of the loadings equals the number of indicators\n  #   The sum of the intercepts equals zero\n  p1 + p2 + p3 == 3\n  n1 + n2 + n3 == 3\n\n  ip1 + ip2 + ip3 == 0\n  in1 + in2 + in3 == 0\n\"\n```\n:::\n\n\n\n#### Fit the model and get the summary\n\nAs before, the `group.equal = c(\"loadings\", \"intercepts\")` statement in the `sem()` function forces corresponding loadings and intercepts to be equal across the groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3_fit <- sem(m3, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m3_fit, standardized = TRUE, fit.measures = TRUE)\n```\n:::\n\n\nCompare the output with \"Method 3\" in Table 2 (pp. 64-65).\n\n\n#### A shortcut\n\n**Lavaan** can do effects-scaling automatically -  set `effect.coding = TRUE` in the `sem()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm3_short <- \"\n  # Measurement Model\n  POS =~ pos1 + pos2 + pos3\n  NEG =~ neg1 + neg2 + neg3\n\"\n\nm3_short_fit <- sem(m3_short, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, effect.coding = TRUE,\n   group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m3_short_fit, standardized = TRUE, fit.measures = TRUE)\n```\n:::\n\n\n\n## Fit measures\n\nLS&C state that the models \"produce overall model fit statistics that are identical\" (p. 66). The following shows how to extract fit measures from all models presented here, and present them in a table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#  A function to extract fit measures\nGetFit <- function(fit, ...) {\n   fitMeasures(fit, ...)\n}\n\n#  Add the fitted lavaan objects to a list\nmodels <- list(\n   \"Method 1\"          = m1_fit,\n   \"Method 1 Shortcut\" = m1_short_fit,\n   \"Method 2c\"         = m2c_fit,\n   \"lavaan Default\"    = m2c_default_fit,\n   \"Method 3\"          = m3_fit,\n   \"Method 3 Shortcut\" = m3_short_fit)\n\n#  Select the fit measures\nmeasures <- c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"tli\", \"rmsea\",\n   \"rmsea.ci.lower\", \"rmsea.ci.upper\")\n\n#  Get fit measures in a table\ntab <- sapply(models, GetFit, measures)\ntab <- t(round(tab, 4)); tab\n```\n:::\n\n\nCompare the fit measures with those presented on page 66.\n\n<br />\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"R code with minimal commenting\"}\n## Little, T., Slegers, D., & Card, N. (2006). A non-arbitrary method\n## of identifying and scaling latent variables in SEM and MACS models.\n## Structural Equation Modeling, 13(1), 59-72.\n\n## Load package\nlibrary(lavaan)\n\n## Get the data from Appendix A\n# 7th grade\ncor7 <- c(\n   1.00000,\n   0.75854,  1.00000,\n   0.76214,  0.78705,  1.00000,\n   0.02766,  0.00973, -0.05762,  1.00000,\n  -0.06112, -0.06105, -0.14060,  0.78501,  1.00000,\n  -0.02222, -0.05180, -0.10250,  0.81616,  0.81076,  1.00000)\n\nmean7 <- c(3.13552, 2.99061, 3.06945, 1.70069, 1.52705, 1.54483)\nsd7   <- c(0.66770, 0.68506, 0.70672, 0.71418, 0.66320, 0.65276)\nn7    <- 380\n\n# 8th grade\ncor8 <- c(\n   1.00000,\n   0.81366,  1.00000,\n   0.84980,  0.83523,  1.00000,\n  -0.18804, -0.15524, -0.21520,  1.00000,\n  -0.28875, -0.24951, -0.33769,  0.78418,  1.00000,\n  -0.29342, -0.21022, -0.30553,  0.79952,  0.83156,  1.00000)\n\nmean8 <- c(3.07338, 2.84716, 2.97882, 1.71700, 1.57955, 1.55001)\nsd8   <- c(0.70299, 0.71780, 0.76208, 0.65011, 0.60168, 0.61420)\nn8    <- 379\n\n## Get the variable names from Appendix A\nnames <- c(\"pos1\", \"pos2\", \"pos3\", \"neg1\", \"neg2\", \"neg3\")\n\n## Combine into lists\ncor  <- list(\"Grade 7\" = cor7, \"Grade 8\" = cor8)\nsd   <- list(sd7, sd8)\nmean <- list(mean7, mean8)\nn    <- list(n7, n8)\n\n## Get the co/variance matrices\ncov <- Map(getCov, x = cor, sds = sd, names = list(names, names))\n\n## The model - Reference-Group Method\nm1 <- \"\n  # Measurement Model\n  #   - Free the 1st loading so it can be estimated\n  POS =~ NA*pos1 + pos2 + pos3\n  NEG =~ NA*neg1 + neg2 + neg3\n\n  # Latent variances and covariance\n  #   - Constrain latent variances to 1 in first group\n  POS ~~ c(1,NA)*POS\n  NEG ~~ c(1,NA)*NEG\n  POS ~~ NEG\n\n  # Indicator intercepts\n  pos1 ~ 1\n  pos2 ~ 1\n  pos3 ~ 1\n  neg1 ~ 1\n  neg2 ~ 1\n  neg3 ~ 1\n\n  # Latent means\n  #   - Constrain latent means to 0 in first group\n  POS ~ c(0,NA)*1\n  NEG ~ c(0,NA)*1\n\"\n\n## Fit the model and get the summary\n#  Compare with \"Method 1\" in Table 2\nm1_fit <- sem(m1, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m1_fit, standardized = TRUE, fit.measures = TRUE)\n\n## Reference-Group Method - Shortcut\nm1_short <- \"\n  # Measurement Model\n  POS =~ pos1 + pos2 + pos3\n  NEG =~ neg1 + neg2 + neg3\n\"\n\nm1_short_fit <- sem(m1_short, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, std.lv = TRUE,\n   group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m1_short_fit, standardized = TRUE, fit.measures = TRUE)\n\n## To see all means including those set to zero\nsummary(m1_short_fit, remove.unused = FALSE, standardized = TRUE,\n   fit.measures = TRUE)\n\n## The model - Marker-Variable Method\nm2c <- \"\n  # Measurement Model\n  #   - Free the 1st loading in POS so it can be estimated\n  #   - Constrain 3rd loading in POS to 1 in both groups\n  #   - Constrain 1st loading in NEG to 1 in both groups\n  POS =~ NA*pos1 + pos2 + c(1,1)*pos3\n  NEG =~ c(1,1)*neg1 + neg2 + neg3\n\n  # Latent variances and covariance\n  POS ~~ POS\n  NEG ~~ NEG\n  POS ~~ NEG\n\n  # Indicator intercepts\n  #   - Constrain 3rd intercept in POS to 0 in both groups\n  #   - Constrain 1st intercept in NEG to 0 in both groups\n  pos1 ~ 1\n  pos2 ~ 1\n  pos3 ~ c(0,0)*1\n  neg1 ~ c(0,0)*1\n  neg2 ~ 1\n  neg3 ~ 1\n\n  # Latent means\n  POS ~ 1\n  NEG ~ 1\n\"\n\n## Fit the model and get the summary\n#  Compare with \"Method 2c\" in Table 2\nm2c_fit <- sem(m2c, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m2c_fit, standardized = TRUE, fit.measures = TRUE)\n\n## Lavaan default method of scaling\nm2c_default <- \"\n  # Measurement Model\n  POS =~ pos1 + pos2 + pos3\n  NEG =~ neg1 + neg2 + neg3\n\"\n\nm2c_default_fit <- sem(m2c_default, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m2c_default_fit, remove.unused = FALSE,\n   standardized = TRUE, fit.measures = TRUE)\n\n## The model - Effects-Scaling Method\nm3 <- \"\n  # Measurement Model\n  #   - Free the 1st loading so it can be estimated\n  #   - Label the loadings so they can be used in the constraints\n  POS =~ NA*p1*pos1 + p2*pos2 + p3*pos3\n  NEG =~ NA*n1*neg1 + n2*neg2 + n3*neg3\n\n  # Latent variances and covariance\n  POS ~~ POS\n  NEG ~~ NEG\n  POS ~~ NEG\n\n  # Indicator intercepts\n  #   - Label the intercepts so they can be used in the constraints\n  pos1 ~ ip1*1\n  pos2 ~ ip2*1\n  pos3 ~ ip3*1\n  neg1 ~ in1*1\n  neg2 ~ in2*1\n  neg3 ~ in3*1\n\n  # Latent means\n  POS ~ 1\n  NEG ~ 1\n\n  # Constraints\n  # For each construct:\n  #   The sum of the loadings equals the number of indicators\n  #   The sum of the intercepts equals zero\n  p1 + p2 + p3 == 3\n  n1 + n2 + n3 == 3\n\n  ip1 + ip2 + ip3 == 0\n  in1 + in2 + in3 == 0\n\"\n\n## Fit the model and get the summary\n#  Compare with \"Method 3\" in Table 2\nm3_fit <- sem(m3, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m3_fit, standardized = TRUE, fit.measures = TRUE)\n\n## Effects-Scaling Method - Shortcut\nm3_short <- \"\n  # Measurement Model\n  POS =~ pos1 + pos2 + pos3\n  NEG =~ neg1 + neg2 + neg3\n\"\n\nm3_short_fit <- sem(m3_short, sample.cov = cov, sample.nobs = n,\n   sample.mean = mean, effect.coding = TRUE,\n   group.equal = c(\"loadings\", \"intercepts\"))\nsummary(m3_short_fit, standardized = TRUE, fit.measures = TRUE)\n\n## Get fit measures\n#  A function to extract fit measures\nGetFit <- function(fit, ...) {\n   fitMeasures(fit, ...)\n}\n\n#  Add the fitted lavaan objects to a list\nmodels <- list(\n   \"Method 1\"          = m1_fit,\n   \"Method 1 Shortcut\" = m1_short_fit,\n   \"Method 2c\"         = m2c_fit,\n   \"lavaan Default\"    = m2c_default_fit,\n   \"Method 3\"          = m3_fit,\n   \"Method 3 Shortcut\" = m3_short_fit)\n\n#  Select the fit measures\nmeasures <- c(\"chisq\", \"df\", \"pvalue\", \"cfi\", \"tli\", \"rmsea\",\n   \"rmsea.ci.lower\", \"rmsea.ci.upper\")\n\n#  Get fit measures in a table\ntab <- sapply(models, GetFit, measures)\ntab <- t(round(tab, 4)); tab\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}